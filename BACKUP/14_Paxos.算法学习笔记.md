# [Paxos 算法学习笔记](https://github.com/zzy131250/gitblog/issues/14)

> 搬运自老博客，发表时间：2017-04-30

# 前言
前段时间实习，是做一个分布式的数据库系统，当然只是拿开源的分布式系统来使用一下。那时候，简单看了下分布式的基础算法——Paxos算法。最近看书又遇到了，打算好好学习一下，但是发现书上讲的好难懂，于是上网找，发现了土豆（更新：土豆上该视频已下架，链接改为b站的视频）上李海磊老师讲解Paxos的视频，讲得很到位，这里记录一下主要内容。

# Paxos 算法
## 简介
Paxos算法由Lamport于1990年提出，它是一种基于消息传递且具有高度容错特性的一致性算法。Paxos算法用来确定一个不可变变量的取值，它可以是任意取值，且一旦取值确定，就不再更改，且可被获取。在分布式系统中，可以把它理解为协商一个一致的数据操作序列。这在分布式系统中很重要，因为分布式系统的数据通常有多个副本。如何通过协调，让多个副本执行相同的操作序列，进而保证数据一致性，是分布式系统要解决的基本问题。

## 问题定义
可以把Paxos算法要解决的问题定义为：设计一个系统来存储名为var的取值，这个系统由acceptor来接收var值，由proposer发出var值。系统需要保证var的取值具有一致性，并需要保证具有容错性。这里不考虑acceptor故障丢失var信息问题和拜占庭将军问题。
解决这个问题，关键在以下四个方面：
1. 管理多个proposer的并发执行
2. 保证var取值的不可变性
3. 容忍proposer机器故障
4. 容忍半数以下acceptor机器故障

# 方案一
方案一先从简单的情况着手，我们先考虑系统由单个acceptor组成。这种情况下，可以通过类似互斥锁的机制来**管理proposer的并发执行**。proposer须先申请到acceptor的互斥访问权，然后再请求acceptor接受自己的值。acceptor负责发放互斥访问权，并接受得到互斥访问权的proposer发出的值。一旦acceptor接受了某个proposer的取值，就认为var值被确定，其他proposer**不再更改var值**。

## 具体实现
Acceptor：
1. 保存一个变量var和一个互斥锁lock
2. prepare()方法加锁，并返回当前var值
3. release()方法解锁，回收互斥访问权
4. accept(var, V)，如果已经加锁，且var值为空，则设置var为V并释放锁

Proposer（两阶段）：
- 第一阶段：通过Acceptor::prepare()尝试获取互斥访问权和var值，如果无法获取，则结束
- 第二阶段：根据var值选择执行方案。如果var值为空，则通过Acceptor::accept(var, V)提交V值；如果var值不为空，则释放锁，获得var值

## 问题
如果proposer在获得锁之后，释放锁之前发生故障，则系统将进入死锁。该方案不能容忍proposer机器故障。

# 方案二

