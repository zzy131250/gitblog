# [KMP 算法](https://github.com/zzy131250/gitblog/issues/29)

> 搬运自老博客，发表时间：2020-02-01

# 前言
在字符串匹配问题中，有很多经典算法。其中，KMP算法是单模字符串匹配的“终极”算法。
KMP算法是根据三位作者（D.E. Knuth、J.H. Morris、V.R. Pratt）的名字来命名的，算法全称为 Knuth Morris Pratt 算法，简称KMP算法。

# 问题简述
单模字符串匹配，指的是一个字符串 a 和一个字符串 b 进行匹配，a 的长度远大于 b，需要查找在 a 中是否包含 b。其中 a 称为主串，b 称为模式串。

# 问题分析
我们能想到的最简单的办法，就是模式串在主串中滑动，从前往后依次查看有没有匹配的串。如下图：
![31e97a47f46e9dcf.png](https://github.com/zzy131250/gitblog/assets/7437470/03ce8bcb-eb66-4e01-bca5-96a90ec4a9c2)

这种算法称为BF算法，或朴素匹配算法。算法的最坏时间复杂度为 O(n∗m)，其中 n 为主串长度，m 为模式串长度。
下面，我们思考一个问题：在遇到不匹配的字符时，我们只是把模式串向后移动一位，是不是效率低了？有没有办法让模式串多向后移动几位？KMP算法，正是基于这个初衷，提出来的。

# 坏字符与好前缀
在介绍KMP算法之前，我们先介绍一些前置概念。
如下图，在主串和模式串匹配过程中，遇到的不能匹配的字符，我们称之为坏字符。相应的，我们把坏字符前，已经匹配的前缀子串称为好前缀。
![b07eac8e9576dd3a.png](https://github.com/zzy131250/gitblog/assets/7437470/4414130c-b9ae-41c1-a7ab-c3ff6d6551ee)

# 模式串滑动
我们知道，当我们遇到坏字符时，意味着模式串需要向后滑动。那么，我们最多可以滑动多少位呢？
如下图，我们可以考察好前缀的后缀子串与模式串的前缀子串，找到好前缀的后缀子串中，最长的能够与模式串前缀子串匹配的串，然后进行滑动（可以思考下，为什么要求是最长子串？如果不是最长子串，有可能滑动位数过多，导致不能覆盖全部情况，导致漏匹配）。注意，由于此时模式串的前缀子串=好前缀的前缀子串，故我们可以换一种说法，即找到好前缀的后缀子串中，最长的能够与好前缀的前缀子串匹配的串，然后进行滑动。像图中的情况，我们就可以把模式串向后滑动2位。
![97720928e0d134d5.png](https://github.com/zzy131250/gitblog/assets/7437470/5d520107-a8d5-4f41-809f-a486634d60db)

