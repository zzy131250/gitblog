<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/zzy131250/gitblog</id><title>RSS feed of zzy131250's gitblog</title><updated>2023-08-12T00:00:53.336945+00:00</updated><author><name>zzy131250</name><email>zia.zhou@pm.me</email></author><link href="https://github.com/zzy131250/gitblog"/><link href="https://raw.githubusercontent.com/zzy131250/gitblog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><entry><id>https://github.com/zzy131250/gitblog/issues/42</id><title>一些有用的心理学规律</title><updated>2023-08-12T00:00:53.569307+00:00</updated><content type="html"><![CDATA[<h1>峰终定律</h1>
<p>如果在一段体验的高峰和结尾，体验是愉悦的，那么对整个体验的感受就是愉悦的。</p>
<h1>帕金森定律</h1>
<p>任何任务都会拖延，直到所有可用时间都用完。
如果一个人给自己安排了充裕的时间去完成一项工作，他就会放慢节奏或者增加其他项目以便用掉所有的时间。</p>
<h1>二八法则</h1>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/42" rel="alternate"/><category term="2023"/><category term="心理学"/><published>2023-07-23T08:36:46+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/41</id><title>记录下我的爱好</title><updated>2023-08-12T00:00:53.653795+00:00</updated><content type="html"><![CDATA[<h1>读书</h1>
<p>悬疑、科幻、历史</p>
<h1>电视</h1>
<p>日剧</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/41" rel="alternate"/><category term="2023"/><category term="爱好"/><published>2023-07-23T08:07:27+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/40</id><title>《分析模式》笔记</title><updated>2023-08-12T00:00:53.727991+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>2020 年版，马丁·福勒著，钟敬译</p>
</blockquote>
<p>随手记录，对于不熟悉相关领域知识的人来说比较难懂，希望 10 年内能把他看完:)</p>
<h1>第九章 交易</h1>
<p>抽象类型和具体类型</p>
<ul>
<li>如果两个相似类型之间的差别通常可以忽略，那么就可以使用一个抽象超类型。如果两者之间的差别通畅很重要，那么就不要使用抽象超类型。</li>
<li>如果一个抽象类型不会给客户端带来更多工作量，那么就应当提供这个抽象类型。</li>
</ul>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/40" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="读书笔记"/><published>2023-07-22T14:13:12+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/38</id><title>一些工作中值得追求的品质</title><updated>2023-08-12T00:00:53.816917+00:00</updated><content type="html"><![CDATA[<h1>积极主动</h1>
<h2>勇于露拙</h2>
<p>承认自己的无知，勇于暴露错误并善于总结提升，这样才会更快成长。</p>
<h2>善意假设</h2>
<p>Yes and。默认开放信任。从利他的角度思考问题，这样或许能找到一些工作的动力和意义。</p>
<h2>及时反馈</h2>
<p>及时同步进度，暴露风险，反馈问题，不憋大招。</p>
<h1>高标准</h1>
<p>坚持高标准很难，特别是在凡事都有两面的情况下，“追求极致”也可能被认为“吹毛求疵”。但是谁能分辨，谁能评说？对于自己来说，只要坚定信念，明确标准，坚持原则，能自洽且勿忘心安即可。</p>
<h2>不畏难</h2>
<p>做难而正确的事。</p>
<h1>自信且谦卑</h1>
<p>培养自己的原则与方法论，包容开放。</p>
<h1>聚焦</h1>
<h2>提高效率</h2>
<p>通过优化流程、自动化等方式来不断提高效率，完成不重要事项，从而让自己专注在最重要的事项上面。</p>
<h2>以终为始</h2>
<p>想清楚终态，制定实现路径，避免方向性问题。有毅力坚持，把事情做到 done 的状态，避免三分钟热度。</p>
<h1>平常心</h1>
<p>放下期待，专心做事，不过度焦虑，也不过度无聊。
坚定信念，学会在没有资源、没有认可，只有压力的情况下达成目标。</p>
<h2>长期主义</h2>
<p>做长期有价值的事情，工作不一定马上有成果，但长期会有回报。</p>
<h1>情绪稳定</h1>
<p>个人认为这是上述品质的前提，只有情绪稳定的情况下，才能冷静理性分析，从而做到上面的其他品质。否则就会回到原始的应激状态。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/38" rel="alternate"/><category term="2023"/><category term="随想"/><published>2023-07-21T15:47:36+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/37</id><title>《八次危机》读书笔记</title><updated>2023-08-12T00:00:53.903460+00:00</updated><content type="html"><![CDATA[<h1>工业化的三个条件</h1>
<p>原材料
人力
外部债务，债务周期
阿根廷
亚洲金融风暴</p>
<h1>工业化的三个阶段</h1>
<p>原始积累
产业扩张
产业升级</p>
<h1>农民对工业化的贡献</h1>
<p>剪刀差
人力
社会保障</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/37" rel="alternate"/><category term="WIP"/><category term="2023"/><published>2023-07-15T15:06:58+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/36</id><title>友情链接</title><updated>2023-08-12T00:00:53.975569+00:00</updated><content type="html"><![CDATA[<p>这个 Issue 是友情链接的 Issue, 如果你想加到友情链接里，请在这条 Issue 上评论，我打心后会自动加到友情链接里，感谢大家。</p>
<p>格式如下（请参考我下面的 comment）:
冒号为中文冒号 ：</p>
<p>名字：xxxxxx
链接：xxxxxx
描述：xxxxxx</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/36" rel="alternate"/><category term="2023"/><category term="Friends"/><published>2023-07-14T15:09:38+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/32</id><title>微习惯打卡</title><updated>2023-08-12T00:00:54.079776+00:00</updated><content type="html"><![CDATA[<p>这个 Issue 作为微习惯每日打卡贴。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/32" rel="alternate"/><category term="2023"/><category term="记录"/><category term="打卡"/><published>2023-07-05T01:43:07+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/29</id><title>KMP 算法</title><updated>2023-08-12T00:00:54.159959+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2020-02-01</p>
</blockquote>
<h1>前言</h1>
<p>在字符串匹配问题中，有很多经典算法。其中，KMP算法是单模字符串匹配的“终极”算法。
KMP算法是根据三位作者（D.E. Knuth、J.H. Morris、V.R. Pratt）的名字来命名的，算法全称为 Knuth Morris Pratt 算法，简称KMP算法。</p>
<h1>问题简述</h1>
<p>单模字符串匹配，指的是一个字符串 a 和一个字符串 b 进行匹配，a 的长度远大于 b，需要查找在 a 中是否包含 b。其中 a 称为主串，b 称为模式串。</p>
<h1>问题分析</h1>
<p>我们能想到的最简单的办法，就是模式串在主串中滑动，从前往后依次查看有没有匹配的串。如下图：
<img src="https://github.com/zzy131250/gitblog/assets/7437470/03ce8bcb-eb66-4e01-bca5-96a90ec4a9c2" alt="31e97a47f46e9dcf.png" /></p>
<p>这种算法称为BF算法，或朴素匹配算法。算法的最坏时间复杂度为 O(n∗m)，其中 n 为主串长度，m 为模式串长度。
下面，我们思考一个问题：在遇到不匹配的字符时，我们只是把模式串向后移动一位，是不是效率低了？有没有办法让模式串多向后移动几位？KMP算法，正是基于这个初衷，提出来的。</p>
<h2>坏字符与好前缀</h2>
<p>在介绍KMP算法之前，我们先介绍一些前置概念。
如下图，在主串和模式串匹配过程中，遇到的不能匹配的字符，我们称之为坏字符。相应的，我们把坏字符前，已经匹配的前缀子串称为好前缀。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/4414130c-b9ae-41c1-a7ab-c3ff6d6551ee" alt="b07eac8e9576dd3a.png" /></p>
<h2>模式串滑动</h2>
<p>我们知道，当我们遇到坏字符时，意味着模式串需要向后滑动。那么，我们最多可以滑动多少位呢？
如下图，我们可以考察好前缀的后缀子串与模式串的前缀子串，找到好前缀的后缀子串中，最长的能够与模式串前缀子串匹配的串，然后进行滑动（可以思考下，为什么要求是最长子串？如果不是最长子串，有可能滑动位数过多，导致不能覆盖全部情况，导致漏匹配）。注意，由于此时模式串的前缀子串=好前缀的前缀子串，故我们可以换一种说法，即找到好前缀的后缀子串中，最长的能够与好前缀的前缀子串匹配的串，然后进行滑动。像图中的情况，我们就可以把模式串向后滑动2位。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/5d520107-a8d5-4f41-809f-a486634d60db" alt="97720928e0d134d5.png" /></p>
<p>一般的，假设坏字符在主串中的位置为 i，在模式串中的位置为 j，好前缀的最长可匹配前后缀子串（字符串中，前缀子串与后缀子串的最长匹配串）长度为 k，那么，我们需要把模式串向后滑动 j−k 位，并从模式串的 k+1 位开始，继续进行匹配。如下图：
<img src="https://github.com/zzy131250/gitblog/assets/7437470/15c9847b-9f26-44cd-b725-44b20fec21a7" alt="daafd1aca998cf59.png" /></p>
<h2>next数组</h2>
<p>我们发现，可以预先根据模式串，求得各前缀的最长可匹配前后缀子串，记录最长前缀子串的位置，存储在数组中，再和主串进行匹配，快速得到匹配结果。我们把这个数组定义为next数组，很多地方也把这个数组定义为失效函数。
数组的下标是每个前缀结尾字符的下标，数组的值为该前缀的最长可匹配前后缀子串中，前缀子串结尾字符的下标，相当于前缀子串长度 k 减去1。下图为一个例子：
<img src="https://github.com/zzy131250/gitblog/assets/7437470/07871681-1969-4931-9baa-42270918ac9d" alt="5c69f31f548b1f14.png" /></p>
<h3>next数组的求解</h3>
<p>next数组的求解，我们可以利用动态规划的思想。我们知道，对于动态规划，最重要的是找到状态和状态转移方程。在本例中，状态是数组中的值，即模式串每个前缀的最长可匹配前后缀子串中前缀子串的位置。对于状态转移方程，要求得模式串 b 中，第 i 个字符的next值，即 next[i]，我们可以先假设已经求得了 next[0]…next[i−1]，且 next[i−1]=k−1，即子串 b[0,k−1] 是 b[0,i−1] 的最长可匹配前后缀子串。下面，我们分类讨论：</p>
<ol>
<li>
<p>如果 b[k]=b[i]，即 b[k−1] 的下一个字符等于 b[i−1] 的下一个字符，那么，我们可以马上得出结论：b[0,k] 即为 b[0,i] 的最长可匹配前后缀子串，next[i]=k。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/44489a94-0089-46e9-b03f-a5588b8bbba4" alt="b842c4649e12b18d.png" /></p>
</li>
<li>
<p>如果 b[k]!=b[i]，即 b[k−1] 的下一个字符不等于 b[i−1] 的下一个字符。则我们需要找到 b[0，k−1] 的最长前缀子串 b[0,l]，且该串最后一个字符的下一个字符为 b[i]，即 b[l+1]=b[i]。这个时候，我们可得到 next[i]=l+1。</p>
</li>
</ol>
<h2>问题解决</h2>
<p>我们先给出框架代码如下：</p>
<pre><code class="language-Java">// a,b分别是主串和模式串；n,m分別是主串和模式串的长度
public static int kmp(char[] a, int n, char[] b, int m) {
	int[] next = getNexts(b, m);
	// 模式串的索引位置
	int j = 0;
	// i是主串的索引位置
	for (int i = 0; i &lt; n; i++) {
		// 找到坏字符，也就是a[i]和b[j]
		while (j &gt; 0 &amp;&amp; a[i] != b[j]) {
			// 找到最长可匹配前后缀子串长度k-1，并从k位开始继续匹配
			j = next[j - 1] + 1;
		}
		// 主串与模式串匹配，模式串索引后移
		if (a[i] == b[j]) ++j;
		// 找到匹配的模式串了，返回主串中开始匹配的字符位置
		if (j == m) return i - m + 1;
	}
	return -1;
}
</code></pre>
<p>next数组的求解属于比较难理解的部分，代码如下：</p>
<pre><code class="language-Java">// b表示模式串，m表示模式串的长度
public static int[] getNexts(char[] b, int m) {
	int[] next = new int[m];
	next[0] = -1;
	// 最长可匹配前后缀子串中，前缀子串的下标
	int k = -1;
	for (int i = 1; i &lt; m; i++) {
		// 情况2，b[k+1]!=b[i]，循环找b[0,k]的最长前缀子串，直到b[k+1]=b[i]或k=-1（不存在），next[i]=l+1
		while (k != -1 &amp;&amp; b[k + 1] != b[i]) {
			// 每次都赋值为b[0,k]的最长前缀子串位置
			k = next[k];
		}
		// 情况1，b[k+1]=b[i]，next[i]=k+1
		if (b[k + 1] == b[i]) ++k;
		next[i] = k;
	}
	return next;
}
</code></pre>
<p>由上述代码可知，KMP算法的时间复杂度为 O(n+m)，即两个串都遍历一遍即可；空间复杂度为 O(m)，需要申请一个和模式串长度一样的数组。其中 n 为主串长度，m 为模式串长度。</p>
<h1>参考资料</h1>
<p><a href="https://blog.csdn.net/weixin_38073885/article/details/85345215">字符串匹配1———单模式匹配（BF，RK，Sunday，BM，KMP）</a></p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/29" rel="alternate"/><category term="算法"/><category term="字符串匹配"/><category term="2020"/><published>2023-06-30T01:46:47+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/28</id><title>IPTables 学习实践</title><updated>2023-08-12T00:00:54.246547+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2019-06-12</p>
</blockquote>
<h1>概述</h1>
<p>Iptables是一个配置Linux内核防火墙的命令行工具，是Netfilter项目的一部分。Iptables通过封包过滤的方式检测、修改、转发或丢弃IPv4数据包，过滤的方式则采用一系列默认和用户定义的规则。如果匹配到规则，则执行该规则的动作。注意，Iptables的规则是有顺序的，只会执行第一个匹配规则的动作。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/38e96b68-d0df-4596-aba3-186f7ce671dc" alt="8cbddf6ff58c4308.png" /></p>
<h1>概念介绍</h1>
<h2>表（Table）</h2>
<p>Iptables里面有多个表（Table），每个表都定义出自己的默认策略与规则，且每个表的用途都不相同。
Iptables主要包含的表：</p>
<ul>
<li>raw表：用于配置数据包，其中的数据包不会被系统跟踪</li>
<li>filter表：存放所有与防火墙相关操作的默认表</li>
<li>nat表：用于网络地址转换（来源、目的IP、port的转换）</li>
<li>mangle表：用于对特殊封包的修改
<img src="https://github.com/zzy131250/gitblog/assets/7437470/0a45ef67-4dde-40d1-a309-77ad79e59492" alt="c017ffe532d4ad71.png" /></li>
</ul>
<h2>链（Chain）</h2>
<p>Iptables主要包含的链：</p>
<ul>
<li>INPUT链：作用于想要进入本机的封包</li>
<li>OUTPUT链：作用于本机要发送的封包</li>
<li>FORWARD链：作用于要转发的封包</li>
<li>PREROUTING链：作用于路由判断之前</li>
<li>POSTROUTING链：作用于路由判断之后</li>
</ul>
<p>Iptables封包过滤过程（表与链的生效时机）如下图：
<img src="https://github.com/zzy131250/gitblog/assets/7437470/c48f2337-6f74-4eb9-96dc-05eb07645530" alt="f0c53008b78b4655.jpg" /></p>
<h2>规则（Rule）</h2>
<p>位于Iptables上的一系列匹配规则，这些规则包括匹配条件与执行目标（跳转到链、内置目标ACCEPT，DROP，QUEUE和RETURN、扩展目标REJECT和LOG）。
在执行目标为跳转到链时，如果目标链的规则不能提供完全匹配，则会返回到调用链继续寻找匹配规则。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/74a0b7c7-b15a-4bcf-b271-1c1f095ee387" alt="38268c476c086c06.jpg" /></p>
<h2>模块（Module）</h2>
<p>模块可以用来扩展Iptables，如conntrack链接跟踪等。</p>
<h1>实践</h1>
<p>本实践通过配置Iptables规则达到Docker端口映射的目的。实践的机器为CentOS 7.6虚拟机，预先安装了Iptables（v1.4.21）和Docker（v18.09.6）。
Iptables规则可通过iptables -S -t [table]命令查看，最初的Iptables规则列表如下：</p>
<pre><code>*nat
-P PREROUTING ACCEPT # PREROUTING链的默认规则为ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER # 用户自定义的链
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE # 对源地址为172.17.0.0/16网段，出口网桥不是docker0的数据包做动态IP的SNAT
-A DOCKER -i docker0 -j RETURN
*filter
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
</code></pre>
<p>通过 docker run -p 8080:8080 命令，我们添加了端口映射。现在，我们可以直接通过 curl <a href="http://10.0.2.15:8080">http://10.0.2.15:8080</a> 命令访问容器中的服务。其中，10.0.2.15是CentOS宿主机的IP。再次查看Iptables，规则列表变为：</p>
<pre><code>*nat
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A POSTROUTING -s 172.17.0.2/32 -d 172.17.0.2/32 -p tcp -m tcp --dport 8080 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN
-A DOCKER ! -i docker0 -p tcp -m tcp --dport 8080 -j DNAT --to-destination 172.17.0.2:8080
*filter
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
-A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 8080 -j ACCEPT
-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
</code></pre>
<p>我们发现多了三条规则：</p>
<pre><code>*nat
# 对源地址为172.17.0.2/32，目的地址为172.17.0.2/32，目的端口为8080的TCP包做动态IP SNAT
-A POSTROUTING -s 172.17.0.2/32 -d 172.17.0.2/32 -p tcp -m tcp --dport 8080 -j MASQUERADE
# 对入口网桥不是docker0，目的端口为8080的TCP包做DNAT，目的地址为172.17.0.2:8080
-A DOCKER ! -i docker0 -p tcp -m tcp --dport 8080 -j DNAT --to-destination 172.17.0.2:8080
*filter
# 对目的地址为172.17.0.2/32，入口网桥不是docker0，出口网桥是docker0，目的端口是8080的TCP包做ACCEPT
-A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 8080 -j ACCEPT
</code></pre>
<p>下面我们依次手动添加Iptables规则，命令如下：</p>
<pre><code>iptables -t nat -A POSTROUTING -s 172.17.0.2/32 -d 172.17.0.2/32 -p tcp -m tcp --dport 8080 -j MASQUERADE
iptables -t nat -A DOCKER ! -i docker0 -p tcp -m tcp --dport 8080 -j DNAT --to-destination 172.17.0.2:8080
iptables -t filter -A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 8080 -j ACCEPT
</code></pre>
<p>最后，通过curl <a href="http://10.0.2.15:8080">http://10.0.2.15:8080</a> 命令，我们成功访问到了容器中的服务，说明端口映射成功。</p>
<h1>参考资料</h1>
<ol>
<li><a href="http://cn.linux.vbird.org/linux_server/0250simple_firewall.php">鸟哥的Linux私房菜</a></li>
<li><a href="https://wiki.archlinux.org/title/Iptables">Iptables</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/28" rel="alternate"/><category term="网络"/><category term="IPTables"/><category term="2019"/><published>2023-06-30T01:45:40+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/27</id><title>做一只爬虫需要考虑的</title><updated>2023-08-12T00:00:54.327875+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2019-04-10</p>
</blockquote>
<h1>前言</h1>
<p>整理一下做一只可靠的爬虫需要考虑的因素。
一次典型的爬取过程包括下载一个 URL 返回的页面，解析页面中的目标数据，将数据存储起来。那么，可以从网络、解析、存储三个方面来讨论分析。另外，爬虫还需要应对服务端的反爬虫策略。</p>
<h1>网络</h1>
<p>爬虫需要网络访问，网络下载速度越快，那么爬取效率会越高。当然，一般情况下，由于网站的反爬虫策略，爬虫对于网络的要求并不是很高，带宽不需要很大。因为，通常情况下反爬虫策略不允许短时间内的大量访问。
当然，对于客户端而言，最佳实践当然是使用单独的线程或进程进行异步的网络访问，因为 IO 操作相对于 CPU 来说相当耗时。</p>
<h1>解析</h1>
<p>网页的解析，就是从网页中提取需要的数据。主要的解析方式包括正则、Xpath、CSS 选择器等。对于爬虫来说，解析出需要的数据即可，根据不同的网页，可以挑选不同的方式。</p>
<h1>存储</h1>
<p>数据存储主要可分为文件和数据库，如果爬虫爬取的数据量不是很大，那么可以使用文件进行简单存储。而如果数据量达到一定规模，则优先考虑数据库。
数据库又分为关系型数据库，如 MySQL，和非关系型数据库，如 MongoDB。如何选择，则主要看使用场景，两者的对比可参考：<a href="https://www.mongodb.com/zh-cn/compare/mongodb-mysql">MongoDB and MySQL Compared</a>。</p>
<h1>反爬虫策略应对</h1>
<h2>UA识别</h2>
<p>对于通过 User-Agent 识别爬虫的策略，可以伪造 UA，并使用 UA 池，随机切换。另外可以伪装成浏览器爬虫，使用特定的 UA 爬取数据。</p>
<h2>验证码</h2>
<p>对于图片验证码，可以考虑使用 OCR 识别；对于滑块之类的验证手段，可以考虑 Selenium 模拟滑动。验证码是比较难以破解的反爬虫手段，目前也没有完美的方式。</p>
<h2>频率限制</h2>
<p>对于服务端的访问频率限制，可以随机 sleep 一段时间再爬取。</p>
<h2>动态网页</h2>
<p>对于动态网页，可以使用两种方式。
一是直接找到 Ajax 请求的 URL，进行爬取；二是通过 Selenium + 模拟浏览器，首先渲染出页面，再进行爬取。</p>
<h2>IP封锁</h2>
<p>对于 IP 封锁，可使用 IP 代理池，随机切换 IP 爬取数据。</p>
<h2>Cookie验证</h2>
<p>对于需要登录验证的网站，可以先使用网页登录，然后拿到 Cookie，进行爬取。或者使用 Selenium + 模拟浏览器直接登录，然后爬取数据。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/27" rel="alternate"/><category term="爬虫"/><category term="2019"/><published>2023-06-29T15:01:03+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/26</id><title>JDK 动态代理</title><updated>2023-08-12T00:00:54.408877+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2018-09-02</p>
</blockquote>
<h1>前言</h1>
<p>JDK 动态代理可以让我们很容易地实现代理模式。通过解析动态代理的实现机制，我们可以更好地使用它。</p>
<h1>一个例子</h1>
<p>我们先来写个简单的例子，先定义两个接口 Subject 和 Subject2。</p>
<pre><code class="language-Java">public interface Subject {
    void hello();
}
public interface Subject2 {
    void hello2();
}
</code></pre>
<p>再定义一个实现类来实现上面的两个接口。</p>
<pre><code class="language-Java">public class SubjectImpl implements Subject, Subject2 {
    @Override
    public void hello() {
        System.out.println(&quot;hello world&quot;);
    }
    @Override
    public void hello2() {
        System.out.println(&quot;hello world, two&quot;);
    }
}
</code></pre>
<p>下面，我们还得实现 InvocationHandler 接口，这个接口有一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。我们在其中加入了处理逻辑，用于在实际调用方法之前打印一句 log，这也是动态代理常用的一个场景。</p>
<pre><code class="language-Java">public class IHandler implements InvocationHandler {
    private Object object;
    IHandler(Object object) {
        this.object = object;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;log: before hello&quot;);
        method.invoke(object, args);
        return null;
    }
}
</code></pre>
<p>最后，我们写一个 main 方法，来测试动态代理。</p>
<pre><code class="language-Java">public static void main(String[] args) {
    Subject subject = new SubjectImpl();
    InvocationHandler handler = new IHandler(subject);
    Subject s = (Subject) Proxy.newProxyInstance(IHandler.class.getClassLoader(),
            new Class&lt;?&gt;[]{Subject.class, Subject2.class}, handler);
    Subject2 s2 = (Subject2) Proxy.newProxyInstance(IHandler.class.getClassLoader(),
            new Class&lt;?&gt;[]{Subject.class, Subject2.class}, handler);
    s.hello();
    s2.hello2();
}
</code></pre>
<p>运行之后，可以看到控制台的输出如下：</p>
<pre><code class="language-Java">log: before hello
hello world
log: before hello
hello world, two
</code></pre>
<p>这里有两个注意点：</p>
<ol>
<li>在 invoke 方法中，不能使用参数中的 proxy 来调用方法，这样会导致循环调用，最终导致栈溢出。</li>
<li>在 main 方法中， subject 的对象声明可以是 Subject、Subject2、SubjectImpl中的任意一个，因为这里不是根据对象的声明来调用方法。</li>
</ol>
<p>附上类图供参考。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/b83e2f46-8926-42a8-ad25-336fc64d4c2f" alt="371ac0890df7772b.png" /></p>
<h1>原理分析</h1>
<p>下面，我们来分析一下动态代理的源码实现，这里我们使用的是 JDK 1.8.0_144 版本。我们先来看下 Proxy.newProxyInstance() 这个方法，这个方法接收一个 ClassLoader，一组接口和一个 InvocationHandler。</p>
<pre><code class="language-Java">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException {
	...
	// 根据类加载器和接口获取代理类
	Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
	...
	// 获取代理类的构造方法
	final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
	...
	// 使用构造方法新建一个实例，并将 InvocationHandler 参数传入
	return cons.newInstance(new Object[]{h});
	...
}
</code></pre>
<p>这里的关键是 getProxyClass0() 这个方法，我们看到方法里面是从一个 cache 中获取代理类。这个 cache 的作用是缓存已经生成的代理类以便后续使用，如果没有符合要求的代理类，则会根据该 cache 构造方法传入的 ProxyClassFactory 生成一个我们需要的代理类。下面我们看下 ProxyClassFactory 的实现，它主要实现了一个 apply() 方法，来生成代理类。</p>
<pre><code class="language-Java">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {
	...
	// 为代理类命名
	long num = nextUniqueNumber.getAndIncrement();
	String proxyName = proxyPkg + proxyClassNamePrefix + num;
	// 动态生成代理类的字节码数组
	byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);
	...
}
</code></pre>
<p>继续看 ProxyGenerator.generateProxyClass() 方法的实现。里面主要调用了 ProxyGenerator 的 generateClassFile() 方法，而该方法主要的作用是为代理类添加代理方法，将他设置为 Proxy 类的子类，然后转成字节码数组并返回。
在获取代理类之后，我们调用构造方法，生成了代理类实例对象。想看下我们生成的代理类长什么样吗？我们可以使用 IntelliJ IDEA 并在 main 方法第一行加一句：</p>
<pre><code class="language-Java">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);
</code></pre>
<p>这样，我们就可以在项目目录下的 com.sun.proxy 包中看到动态生成的代理类了。</p>
<pre><code class="language-Java">public final class $Proxy0 extends Proxy implements Subject, Subject2 {
    
    public final void hello2() throws  {
        try {
            super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
    public final void hello() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
}
</code></pre>
<p>如我们所料，生成的 $Proxy0 类继承了 Proxy 类，并且实现了 Subject、Subject2 接口。而方法则通过调用父类 Proxy 的 InvocationHandler 的 invoke() 方法来实现。</p>
<h1>参考资料</h1>
<p><a href="https://developer.ibm.com/languages/java/">Java 动态代理机制分析及扩展，第 1 部分</a></p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/26" rel="alternate"/><category term="Java"/><category term="动态代理"/><category term="2018"/><published>2023-06-29T14:02:30+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/25</id><title>技术脑图整理</title><updated>2023-08-12T00:00:54.497481+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2018-02-23</p>
</blockquote>
<h1>前言</h1>
<p>这是我看书的笔记做成的脑图，整理在这里，会经常更新。</p>
<h1>脑图</h1>
<h2>Java SE</h2>
<p><a href="http://naotu.baidu.com/file/6133290b534f386f5dfd4d87c271344a?token=a1df85c8c36a9abb">周志明. 深入理解Java虚拟机[M]. 机械工业出版社, 2011.</a>
<img src="https://github.com/zzy131250/gitblog/assets/7437470/c7832042-1f05-4324-9732-799dd5b84bd6" alt="e954472eada78280.jpg" /></p>
<p><a href="http://naotu.baidu.com/file/06edfb64478a01834f02d9d68c89666f?token=24a9c6171376724a">BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.</a>
<img src="https://github.com/zzy131250/gitblog/assets/7437470/8ed68215-3fc5-447d-aeca-7b11eae6299d" alt="cf20016a0f53de65.jpg" /></p>
<h2>Java EE</h2>
<p><a href="http://naotu.baidu.com/file/687f5efea4057ad18cfe68906708ddb8?token=d1219e67e943a79c">王福强. Spring揭秘[M]. 人民邮电出版社, 2009.</a>
<img src="https://github.com/zzy131250/gitblog/assets/7437470/56170efb-397e-4bdc-8017-65f70a4f63cf" alt="427a20abfa83d3a5.jpg" /></p>
<h2>服务器</h2>
<p><a href="http://naotu.baidu.com/file/b389d807cb8115387eed9ad0535ae18f?token=901af3903971ac59">陶辉. 深入理解Nginx.第2版[M]. 机械工业出版社, 2016.</a>
<img src="https://github.com/zzy131250/gitblog/assets/7437470/74b0ca8e-b5b6-4fff-b887-e0236603d6c8" alt="5798f9ab4dc297a1.jpg" /></p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/25" rel="alternate"/><category term="读书笔记"/><category term="2018"/><published>2023-06-29T13:57:20+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/24</id><title>马尔科夫模型</title><updated>2023-08-12T00:00:54.587344+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-09-07</p>
</blockquote>
<h1>要素</h1>
<ul>
<li>状态集合</li>
<li>状态转换概率矩阵</li>
</ul>
<h1>前提</h1>
<h2>马尔科夫假设</h2>
<p>某个状态出现的概率仅依赖于前m个状态，称为m阶马尔科夫模型；特别地，若m=1，则称此模型为一阶马尔科夫模型。</p>
<h2>贝叶斯公式（条件概率）</h2>
<h1>一阶马尔科夫模型的应用</h1>
<h2>给定模型，求某序列出现的概率</h2>
<h2>给定状态集合和某序列，求模型的参数</h2>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/24" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="NLP"/><published>2023-06-29T13:55:55+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/23</id><title>反向传播</title><updated>2023-08-12T00:00:54.673779+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-08-19</p>
</blockquote>
<h1>前言</h1>
<p>反向传播算法是一种训练人工神经网络的常用方法。它通过计算网络中所有权重的梯度，并对权重进行迭代更新，以最小化损失函数。
根据上面的介绍，我们可以得知，反向传播算法的关键，是找出每个权重的梯度，然后可以使用前面讲到的<a href="https://github.com/zzy131250/gitblog/issues/21">梯度下降方法</a>，进行权重的更新。</p>
<h1>三层网络的例子</h1>
<p>我们先来看最基本的三层网络。如图，这三层网络分别称为输入层、隐藏层、输出层。对于隐藏层和输出层的每个神经元，输入是上一层输出值的加权和，输出是一个函数值。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/c35b1efd-482b-4bda-95b6-2682ce7ea7cc" alt="413c53aca59f366c.jpg" /></p>
<h2>正向计算输出</h2>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/23" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="深度学习"/><published>2023-06-29T13:54:42+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/22</id><title>动态规划（二）——最长递增子序列（LIS）</title><updated>2023-08-12T00:00:54.770530+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-08-06</p>
</blockquote>
<h1>前言</h1>
<p>在遥远的上一篇，我们介绍了动态规划的第一个问题——<a href="https://github.com/zzy131250/gitblog/issues/13">背包问题</a>。这篇，我们接着介绍另一个初级问题——最长递增子序列(LIS)。</p>
<h1>问题简述</h1>
<p>给定一个数字序列 a1,a2,…,an ，求其中最长的递增子序列长度。举个栗子，现在有序列 2,3,5,4,1,6 ，那么最长递增子序列就是 2,3,5,6 和 2,3,4,6 ，长度为4，我们不关注子序列的元素在原序列中是否相邻。</p>
<h1>问题分析</h1>
<p>根据上一篇的经验，要解决动态规划问题，关键是找出状态及状态转移方程。现在，我们循着这个思路，尝试解决。
首先是状态，我们可以怎样定义状态呢？首先想到的，是把前i个数字序列的LIS长度d[i]作为状态。找到状态，接着找状态转移方程。假设我们已经找到了d[1]，d[2]，…，d[i]，如何找出d[i+1]呢？我们发现，要确定d[i+1]，需要知道ai+1与前面数字的大小。这就带来一个问题——我们在记录d[i]时，并没有记录d[i]对应的末尾数字，这让我们陷入困境。
我们需要更新状态的定义。
根据上面的分析，我们把状态d[i]定义为：前i个数字序列，且以ai作为结尾的LIS长度。那么，d[i+1]就是d[1]，d[2]，…，d[i]中末尾数字小于ai+1的最大值，即d[i+1]=max{d[k]|ak&lt;ai+1,k∈(1,i)}。
在给出代码之前，先插播一下我关于使用循环还是递归的一些看法。在上一篇中，我们给出了递归与循环两种方式的实现，但是个人感觉递归更加容易理解一点，因为那里有硬性约束——背包容量，适合用递归自顶向下考虑；而这里，我们没有什么硬性约束，且为了得到一个状态，需要预先知道前面所有的状态值，所以，适合用循环自底向上考虑。
下面我们给出代码。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/22" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="动态规划"/><category term="算法"/><published>2023-06-29T13:53:23+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/21</id><title>从最小二乘法到梯度下降法（二）</title><updated>2023-08-12T00:00:54.856712+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-28</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/21" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="优化"/><category term="深度学习"/><published>2023-06-29T05:16:25+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/20</id><title>从最小二乘法到梯度下降法（一）</title><updated>2023-08-12T00:00:54.928345+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-24</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/20" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="优化"/><category term="深度学习"/><published>2023-06-29T01:49:43+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/19</id><title>记一次异常数据过滤算法的优化</title><updated>2023-08-12T00:00:55.009278+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-13</p>
</blockquote>
<p>这段时间公司给了个新的需求：对现有的小区均价异常数据过滤算法进行优化，因为现在的过滤算法过滤了大量正常数据，导致均价变化幅度很大，引起客户的怀疑。</p>
<h1>算法目标</h1>
<p>过滤算法的目标是过滤小区房子的错误数据。由于我们的数据来源是中介网站，可以认为错误数据不会很多。另外，如果有错误数据，也认为这是很容易辨识出来的数据。</p>
<h1>过滤算法V1.0</h1>
<p>现有的过滤算法的基本思想是计算幅度。先将小区中房子的成交价按照时间排序，并选取一个月的价格序列，计算相邻价格之间的变化幅度，按照一定的规则确定异常数据。规则如下：</p>
<pre><code class="language-Python"># 对所有的房子价格求幅度
for n in range(1, len(price_list)-1):
    # 计算前项的幅度
    fn1 = price_list[n] / price_list[n-1] - 1
    # 计算后项的幅度
    fn2 = 1 - price_list[n] / price_list[n+1]
    # 计算平均的幅度
    fn3 = (price_list[n-1] + price_list[n+1]) / 2 / price_list[n]
    # 如果满足下式，则n必为噪点
    if abs(fn1) &gt; a1 and abs(fn2) &gt; b1 and abs(fn3) &gt; c1 and fn1*fn2 &lt; 0:
        noise_index_list.append(n)
        continue
    # 如果满足下式，则n可能为噪点
    if abs(fn1) &gt; a2 and abs(fn2) &lt; b2 and abs(fn3) &lt; c2:
        # 计算n+1的相关指标
        x = n + 1
        if x &lt; len(price_list)-1:
            fx1 = price_list[x] / price_list[x-1] - 1
            fx2 = 1 - price_list[x] / price_list[x+1]
            fx3 = (price_list[x-1] + price_list[x+1]) / 2 / price_list[x]
            # 如果满足下式，则n为噪点
            if abs(fx1) &lt; a2 and abs(fx2) &gt; b2 and abs(fx3) &gt; c2 and fn1*fx2 &lt; 0:
                noise_index_list.append(n)
</code></pre>
<p>上述算法是有一定说服力的，如果某个价格B较前一个价格A上升很多，后一个价格C较B又下降很多，那么可以确定B是异常数据。但是这个算法有一个前提，就是数据整体呈上升趋势。当然，假定房价整体呈上升趋势，这也是说得过去的。
通过分析数据，发现同一个小区的房价数据虽然大体处于同一水平，但有些有明显的分化迹象。比如，某个小区一些房子单价在6万左右，另一些在4万左右。这样的小区，如果单纯地按照上述算法过滤价格，那么很可能将大量正常数据过滤掉。</p>
<h1>过滤算法V2.0</h1>
<p>基于上面的发现，我考虑能否先将价格差异明显的小区均价分类，然后每个类内部再使用过滤算法进行过滤。于是，我想到了聚类。
对于这样的聚类场景，首先想到的，当然是<a href="https://en.wikipedia.org/wiki/Affinity_propagation">AP算法</a>，因为不知道聚类的个数。但是，在简单尝试对几个小区聚类之后，我放弃了，因为聚类结果不理想，类太多。在这个场景下，只有非常明显的价格差异，我们才进行分类，类过多毫无用处。我还是回到<a href="https://zh.wikipedia.org/wiki/K-%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95">K-Means算法</a>，不过，做了一些优化。先计算出各个聚类个数下（从5递减）的聚类中心，如果某次聚类下聚类中心相距较远，那么可以认为该聚类个数比较合理；相反，如果聚类中心相距很近，那么减少聚类个数。
在加入分类步骤后再过滤数据，使得很多正常数据得以保留，算法也更合理。但是，仍会有一些正常数据被删掉。继续分析被删掉数据，发现它们大多是与相邻聚类中心都很远的数据。比如，一个聚类中心为5万，这个类中有相邻的三个数据4万、6万、4万，它们虽然属于同一类，但是都处于边缘，导致计算它们的幅度时，仍然超出了限制，6万被删除。
这不禁让我回过头来思考，使用相邻价格的变化幅度来过滤数据的正确性。首先，在这个场景下，相邻数据的上升趋势不明显；另外，我们考虑的是房子的成交单价，一般来说，一套房子只能成交一次，相邻的价格就是两套房子的成交单价，它们其实没有那么多变化幅度上的关联。</p>
<h1>过滤算法V3.0</h1>
<p>根据上面的思考，再结合我们这个场景下的过滤目标，我决定改变原有的计算变化幅度的算法，转而寻找新的算法。通过查阅网上资料，我发现了用于去除噪声的<a href="https://baike.baidu.com/item/%E6%8B%89%E4%BE%9D%E8%BE%BE%E5%87%86%E5%88%99">拉依达准则</a>：假设一个集合，均值为μ，按贝塞尔公式计算出标准偏差为σ，那么，我们可以认为大部分数据都会在(μ-3σ, μ+3σ)之间，如果一个数据超出这个范围，我们就认为它是异常数据。拉依达准则主要考虑数据与均值的距离，而不是相邻点的幅度，这比较符合我们的使用场景。</p>
<h1>结果</h1>
<p>至此，我们得到了改进的算法：</p>
<ol>
<li>通过价格聚类，将小区价格分类</li>
<li>对每个类，计算数据与类中心的距离（拉依达准则），决定是否过滤</li>
</ol>
<p>目前，这个算法取得了最好的效果，符合过滤的预期。当然，还是有改进的余地，如果大家有什么好的建议，请不吝赐教！</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/19" rel="alternate"/><category term="2017"/><category term="算法"/><category term="优化"/><published>2023-06-29T01:48:25+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/18</id><title>布隆过滤器</title><updated>2023-08-12T00:00:55.093693+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-09</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/18" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="算法"/><category term="哈希"/><published>2023-06-28T15:06:02+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/17</id><title>Python 库推荐</title><updated>2023-08-12T00:00:55.176934+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-02</p>
</blockquote>
<h1>前言</h1>
<p>工欲善其事，必先利其器。Python作为强大的脚本语言，其很大的优势就在于众多优秀的库。这里推荐一些个人觉得很好用的库，本文持续更新。</p>
<h1><a href="https://pypi.org/project/requests/">requests</a></h1>
<p>易用的HTTP库。”Python HTTP for Humans.”这是requests的口号。</p>
<h1><a href="https://pypi.org/project/BeautifulSoup/">beautifulsoup</a></h1>
<p>好用的HTML解析工具。
<a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/">使用手册</a></p>
<h1><a href="https://pypi.org/project/python-dateutil/">dateutil</a></h1>
<p>日期处理工具，令人激动的是，它的parse函数可以自动识别多种字符串，如”2017-01-01”、”01/01/2017”、”2017.01.01”，并直接转成datetime，很方便！另外，它还提供rrule函数，用于根据指定条件生成日期序列。
<a href="https://dateutil.readthedocs.io/en/latest/">使用手册</a></p>
<h1>profile(built-in)</h1>
<p>这是Python的一个内建函数，可以用于进行性能分析。</p>
<h1><a href="https://pypi.org/project/pyenv/">pyenv</a></h1>
<p>Linux下的Python版本管理神器！简单好用，可以指定某个目录使用的Python版本。
<a href="https://github.com/pyenv/pyenv/wiki">使用手册</a></p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/17" rel="alternate"/><category term="2017"/><category term="Python"/><category term="库"/><published>2023-06-28T15:05:03+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/16</id><title>IO 复用</title><updated>2023-08-12T00:00:55.261010+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-01</p>
</blockquote>
<h1>前言</h1>
<p>阻塞、非阻塞、同步、异步，这些IO名词经常听到，但是很容易混淆，这里记录一下他们的区别与联系。</p>
<h1>IO 模型概览</h1>
<p>上述词语都和IO编程相关，我们先来了解一下IO模型。依据《UNIX网络编程》的说法，IO模型共分为五种，分别为：</p>
<ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO复用</li>
<li>信号驱动IO</li>
<li>异步IO</li>
</ul>
<p>下面分别简单介绍之。</p>
<h2>阻塞IO模型</h2>
<p>这是最基本的IO模型，进程通过recvfrom系统调用向内核请求数据，在内核准备好数据并返回给进程之前，进程一直阻塞等待。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/de118e8a-7738-42e5-a471-4678b6ff5dea" alt="c2987e344eb74683.png" /></p>
<h2>非阻塞IO模型</h2>
<p>在非阻塞IO模型中，进程不是被动等待数据返回，而是每隔一段时间就使用recvfrom系统调用询问（轮询）内核数据是否准备好。若还未准备好，则内核会返回一个EWOULDBLOCK错误；若准备好，则进程执行recvfrom系统调用。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/32b4601e-b2e5-4db7-9957-8e4d4f0dd0e2" alt="517ed87866a96306.png" /></p>
<h2>IO复用模型</h2>
<p>在IO复用模型中，多个进程可以同时请求数据并阻塞，使用select或poll系统调用，由select或poll代为请求内核的系统调用。当某个进程的数据准备好之后，即通知该进程执行recvfrom系统调用，其他进程继续等待。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/dba75fdc-b7c4-48c9-89e6-8ff78be4d874" alt="5e9e78495bae8a2a.png" /></p>
<h2>信号驱动IO模型</h2>
<p>通过系统调用sigaction，为进程安装一个信号处理程序，进程可以非阻塞地继续执行。当数据准备好，内核为进程生成一个信号，通知进程，然后进程执行recvfrom系统调用。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/f6c7ccbb-b47f-4d5b-ad4d-9175d763dfff" alt="d382490c447f9363.png" /></p>
<h2>异步IO模型</h2>
<p>异步IO与信号驱动IO类似，都是由内核通知进程，但是区别在于：信号驱动IO是由内核通知进程何时可以启动一个IO操作，而异步IO是由内核通知进程IO操作何时完成。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/5b7b3bd6-67f3-4199-9f0e-35ee3c04288a" alt="bae9f8aa06e61d9b.png" /></p>
<h1>IO模型比较</h1>
<p>前四种IO模型的主要区别都在第一阶段，而第二阶段，在数据从内核拷贝到用户空间时，都是阻塞于recvfrom调用；异步IO的两个阶段都不同于前四种模型。
<img src="https://github.com/zzy131250/gitblog/assets/7437470/a6aecea6-5695-41f8-8114-c55c5d69980f" alt="0a91ca3466b600c7.png" /></p>
<h1>同步IO与异步IO</h1>
<p>Posix.1定义：</p>
<ul>
<li>同步IO操作引起请求进程阻塞，直至IO操作完成</li>
<li>异步IO操作不引起请求进程阻塞</li>
</ul>
<p>根据上面的定义，前四种模型都是同步模型，而异步IO模型属于异步模型。</p>
<h1>总结</h1>
<p>同步、异步的区别是返回结果的方式：同步是直接返回结果；异步是通过通知、回调等方式返回结果。
阻塞、非阻塞都描述同步IO模型，他们的区别是进程等待结果时的状态：阻塞是进程挂起等待；非阻塞是进程继续执行，不挂起，并进行轮询。</p>
<h1>参考资料</h1>
<ol>
<li><a href="https://m.douban.com/book/subject/1500149/">UNIX网络编程</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/16" rel="alternate"/><category term="2017"/><category term="IO"/><category term="异步"/><published>2023-06-28T14:52:23+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/15</id><title>目标遐想</title><updated>2023-08-12T00:00:55.347371+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-05-14</p>
</blockquote>
<p>一直认为自己是一个目标明确的人，但有时候还是会对目标有些疑惑。我想，不如在这里记录下自己的思考，让头脑不再模糊。</p>
<p>记得在刚进大学那会儿，觉得世界好大，觉得自己充满好奇，充满活力，什么都想尝试。那时候报了好多社团，迫切地想要拥抱世界，拥抱大学。然而，接下来的时间，我经历了一段迷茫期，觉得对什么都提不起兴趣，觉得人生大概就这样了。我突然很怀念高中那段时光，虽然那时候很累、很苦，但是有目标，有奋斗的动力，愿意付出所有。有朋友说，他不喜欢高中死读书的人，这些人不有趣，不懂得享受生活。但我的看法是，既然有目标，有精力，就为了目标倾尽全力，为了以后不后悔。这在某种程度上也算把自己感动，至少自己不会觉得可惜。</p>
<p>所以，我想我大概是缺了一个目标。</p>
<p>我可能是目的论的拥趸，觉得没有目标，就没有了意义。说到意义，或许，人生本来就没有意义，与世无争也是一种选择。但我总觉得，我拥有了只会有一次的生命，如果不好好珍惜，那该有多可惜啊！</p>
<p>那么，我该把什么当作目标呢？</p>
<p>共产主义的目标是为了全人类的解放，这个目标对我来说，太大，不好把握。功利主义的目标是为最多数人谋取最大利益，对于个人来说，功利主义免不了自私的嫌疑，我不敢苟同。自由主义追求个人的自由，我想，这就是我想要的。</p>
<p>关于自由。这里的自由，是很高的要求，是由自己的理性制定的准则，不是迫于压力，或是被欲望指使。在某种程度上，自由即自律。过去，我也尽量做到自律，但总是容易迷失，不知道为何自律，现在，我明确了目的。</p>
<p>另外，我还想把追求幸福当作个人的目标。当然，这里的幸福，也是种局限的幸福。</p>
<p>首先，它是一种长远的幸福。如果把人生当作一次登山，那么，登上山顶的那一刻，就是最幸福的时刻。但是，你会想让那个时刻在何时出现呢？我们来设想一下，如果那一刻出现在你20岁的时候，那肯定有很多人夸你年少成才，你可以获得极大的荣耀。可是，那之后呢？那之后，你的人生会持续走下坡。相反，如果那个时刻出现在你40岁的时刻，那么在你40岁之前，你的人生都是一个上坡，你会持续的体会到取得成就的幸福感。即使在以后慢慢下坡，你也有理由说服自己，该退休了，这是理所当然的。当然，如果你的人生，不止一次上下坡，而是像过山车一样，上下起伏，我认为那样也是很好的，因为至少有一半时间是上坡。</p>
<p>其次，它是一种高层次的幸福。根据马斯洛的需求层次理论，高层次的需求包含社交需要、尊重需要和自我实现的需要。同样，我所追求的幸福是人际关系良好、自我尊重、自我实现时的幸福。</p>
<p>这段时间有一首很火的小诗，说每个人都有自己的时区，生命就是等待正确的行动时机。我的看法是，光等待是不够的，要行动起来，并等待时机，不然这只会是那些站在原地却幻想成功的人的鸡汤。我喜欢一句相似的话，“但行好事，莫问前程。”我想，这更能催人奋进，也更可能让人获得幸福。</p>
<p>日剧《四重奏》里面，有朱有句台词，“人生轻而易举”。每个人有每个人过自己人生的权利，但是，我不要我的人生轻而易举。</p>
<p>最后，正好趁着母亲节，祝妈妈节日快乐！</p>
<p>2017.05.14 南京</p>
<h1>更新</h1>
<p>一直觉得，似乎自由与幸福就可以是我追求的全部，但最近一些事，似乎一直在印证，还有些东西，也是需要追求的。</p>
<p>这个东西，我觉得是责任。</p>
<p>自由是“从心所欲，不逾矩”，而责任，可以归为“矩”的一部分。从这方面看，目标的排序应该是责任、自由、幸福。</p>
<p>如果不考虑责任，或许会更加幸福。但是，这样的幸福，会变成“不能承受的生命之轻”。不考虑责任，只求自由和幸福，显得自私。</p>
<p>适逢海军成立70周年，祝人民海军生日快乐！</p>
<p>2019.04.23 南京</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/15" rel="alternate"/><category term="2017"/><category term="目标"/><published>2023-06-28T14:11:48+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/14</id><title>Paxos 算法学习笔记</title><updated>2023-08-12T00:00:55.433303+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-04-30</p>
</blockquote>
<h1>前言</h1>
<p>前段时间实习，是做一个分布式的数据库系统，当然只是拿开源的分布式系统来使用一下。那时候，简单看了下分布式的基础算法——Paxos算法。最近看书又遇到了，打算好好学习一下，但是发现书上讲的好难懂，于是上网找，发现了土豆（更新：土豆上该视频已下架，链接改为b站的视频）上李海磊老师讲解Paxos的视频，讲得很到位，这里记录一下主要内容。</p>
<h1>Paxos 算法</h1>
<h2>简介</h2>
<p>Paxos算法由Lamport于1990年提出，它是一种基于消息传递且具有高度容错特性的一致性算法。Paxos算法用来确定一个不可变变量的取值，它可以是任意取值，且一旦取值确定，就不再更改，且可被获取。在分布式系统中，可以把它理解为协商一个一致的数据操作序列。这在分布式系统中很重要，因为分布式系统的数据通常有多个副本。如何通过协调，让多个副本执行相同的操作序列，进而保证数据一致性，是分布式系统要解决的基本问题。</p>
<h2>问题定义</h2>
<p>可以把Paxos算法要解决的问题定义为：设计一个系统来存储名为var的取值，这个系统由acceptor来接收var值，由proposer发出var值。系统需要保证var的取值具有一致性，并需要保证具有容错性。这里不考虑acceptor故障丢失var信息问题和拜占庭将军问题。
解决这个问题，关键在以下四个方面：</p>
<ol>
<li>管理多个proposer的并发执行</li>
<li>保证var取值的不可变性</li>
<li>容忍proposer机器故障</li>
<li>容忍半数以下acceptor机器故障</li>
</ol>
<h1>方案一</h1>
<p>方案一先从简单的情况着手，我们先考虑系统由单个acceptor组成。这种情况下，可以通过类似互斥锁的机制来<strong>管理proposer的并发执行</strong>。proposer须先申请到acceptor的互斥访问权，然后再请求acceptor接受自己的值。acceptor负责发放互斥访问权，并接受得到互斥访问权的proposer发出的值。一旦acceptor接受了某个proposer的取值，就认为var值被确定，其他proposer<strong>不再更改var值</strong>。</p>
<h2>具体实现</h2>
<p>Acceptor：</p>
<ol>
<li>保存一个变量var和一个互斥锁lock</li>
<li>prepare()方法加锁，并返回当前var值</li>
<li>release()方法解锁，回收互斥访问权</li>
<li>accept(var, V)，如果已经加锁，且var值为空，则设置var为V并释放锁</li>
</ol>
<p>Proposer（两阶段）：</p>
<ul>
<li>第一阶段：通过Acceptor::prepare()尝试获取互斥访问权和var值，如果无法获取，则结束</li>
<li>第二阶段：根据var值选择执行方案。如果var值为空，则通过Acceptor::accept(var, V)提交V值；如果var值不为空，则释放锁，获得var值</li>
</ul>
<h2>问题</h2>
<p>如果proposer在获得锁之后，释放锁之前发生故障，则系统将进入死锁。该方案不能容忍proposer机器故障。</p>
<h1>方案二</h1>
<p>为了解决方案一中的死锁问题，<strong>容忍proposer机器故障</strong>，我们引入抢占式访问权。acceptor可以让某个proposer的访问权失效，不再允许其访问，并将访问权重新发放给其他proposer。
为了实现这个目标，我们要求proposer在申请访问权的时候指定编号epoch，越大的epoch越新。acceptor采用“喜新厌旧”的原则，一旦收到更大的epoch，则令旧的访问权失效，然后给最新的epoch发放访问权，并只接受它提交的值。这样会导致拥有旧epoch的proposer无法运行，拥有新epoch的proposer将开始运行。为了保持一致性，不同epoch的proposer之间采用“后者认同前者”的原则，即如果acceptor上已设置了var值，则新的proposer不再更改，并且认同这个取值；如果acceptor上var值为空，proposer才提交自己的值。</p>
<h2>具体实现</h2>
<p>Acceptor：</p>
<ol>
<li>保存var的取值与var对应的accepted_epoch值，并保存最新发放访问权的lastest_epoch值</li>
<li>prepare(epoch)方法先判断参数epoch是否大于自己保存的lastest_epoch，如果大于则更新lastest_epoch为参数epoch值，并返回var的取值；否则返回错误</li>
<li>accept(var, epoch, V)方法先判断参数epoch是否为记录的lastest_epoch值，若相等则更新acceptor的var值与accepted_epoch值；否则返回错误</li>
</ol>
<p>Proposer（两阶段）：</p>
<ul>
<li>第一阶段：申请epoch值和获取var值。可选取当前时间戳作为epoch，调用Acceptor::prepare(epoch)尝试获取epoch轮次的访问权和var的取值，如果不能获取，则结束</li>
<li>第二阶段：根据var值选择执行方案。如果var值为空，则通过Acceptor::accept(var, epoch, V)提交V值，这里提交var值不一定成功，因为有可能在提交时其他proposer已经提交了更大的epoch值，导致当前proposer的访问权失效，此时会返回错误；如果var值不为空，获得并认同var值，不再更改</li>
</ul>
<h2>问题</h2>
<p>由于系统仅有单个acceptor，如果acceptor发生故障，将导致整个系统无法运行。该方案不能容忍acceptor机器故障。</p>
<h1>方案三——Paxos</h1>
<p>在前两种方案中，我们已经解决了部分问题，接下来，我们正式引入Paxos。Paxos在方案二的基础上，引入多个acceptor，并采用少数acceptor服从多数acceptor的思路，可以<strong>容忍半数以下acceptor机器故障</strong>。在Paxos中acceptor的实现与方案二一致，这里我们仅介绍proposer的实现。</p>
<h2>具体实现</h2>
<p>Proposer（两阶段）：</p>
<ul>
<li>第一阶段：申请epoch值和获取var值。由于有多个acceptor，所以规定必须获取半数以上acceptor的访问权，才能进入第二阶段。当然，由于会有抢占epoch的情况，所以可能会有两个proposer分别获取半数以上访问权。但是请注意，这时实际上还是只有一个majority，因为必定有acceptor同时接受了两者，但是该acceptor只记录较大的epoch，所以对于该acceptor来说，只有较大epoch的proposer的访问权有效，结果只有一个proposer提交的值可以在acceptor中形成majority，从而达成一致。（如果有偶数个acceptor，这里可能会产生两个proposer各占一半的情况，在这种情况下，两个proposer都不能进入第二阶段。）</li>
<li>第二阶段：根据var值选择执行方案。如果var值都为空，则通过Acceptor::accept(var, epoch, V)提交V值，如果半数以上acceptor返回成功，则认为提交成功，否则返回错误；如果var值不都为空，则认同最大accepted_epoch对应的var值，并尝试向其他acceptor提交该var值</li>
</ul>
<h2>如何维持一致</h2>
<p>这里我们假设，已经有一个epoch_1形成了一致的var值var_1，即已经有半数以上acceptor的var值确定为epoch_1对应的proposer提交的值var_1。那么，在epoch_1后一次的运行epoch_1+1轮次中，epoch_1+1对应的proposer需要获取半数以上acceptor访问权，所以它必定可以得到上一轮达成一致的var值var_1，并且var_1对应的epoch值epoch_1是已提交的epoch中最大的，那么，它就会认同var值，并继续传播var值，直到全部acceptor达成一致。</p>
<h2>活锁</h2>
<p>这里可能会出现一个活锁问题。我们知道，在proposer第一阶段获取半数以上acceptor访问权之后，可能会有新的proposer抢占它，导致原来的proposer无法继续运行。如果每次都有新的proposer抢占原来的proposer，那么将永远无法形成一致，这就是活锁。Lamport给出的解决方案是在proposer中选举一个leader，只允许leader提交取值，当leader故障时马上选举其他的leader。</p>
<h2>参考资料</h2>
<ol>
<li><a href="https://m.bilibili.com/video/av36134550">paxos和分布式系统</a></li>
<li><a href="https://m.douban.com/book/subject/26598073/">云计算（第三版）</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/14" rel="alternate"/><category term="2017"/><category term="算法"/><category term="Paxos"/><category term="分布式"/><published>2023-06-28T14:03:53+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/13</id><title>动态规划（一）——背包问题</title><updated>2023-08-12T00:00:55.522002+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-04-23</p>
</blockquote>
<h1>简介</h1>
<p>动态规划是一种特殊的算法技巧，它通过把原问题分解为相对简单的子问题的方式来求解复杂问题。</p>
<p>动态规划中，子问题的解被称为状态，状态之间的转换称作状态转换方程。动态规划的核心就是找到状态及状态转换方程。</p>
<p>下面通过动态规划的实例——背包问题，来阐述其方法。</p>
<h1>背包问题</h1>
<h2>问题简述</h2>
<p>有一个人，他背上一个背包去森林里寻宝，发现一堆宝石，但是他的背包容量有限，无法一次装下所有宝石。假设背包容量为capacity，如果把宝石编号为1，2，…，n，宝石的体积分别为volume[0]，volume[1]，…，volume[n-1]，宝石的价值依次为value[0]，value[1]，…，value[n-1]。现在问题来了，这个人如何挑选宝石放进背包，可以使自己获得最大利益？</p>
<h2>问题分析</h2>
<p>这是一个典型的动态规划问题。我们不妨先来假设一下，假设背包容量为10，宝石的体积为5，4，3，宝石的价值为20，10，12。</p>
<p>如果什么都不想，直接排列组合，也是可以的。对于每一个宝石，有两种选择，放入背包，或者不放入背包。这样一共有8种情况，只需再考虑每种情况下背包的容量问题，然后得出最大价值即可。</p>
<p>这种方法的劣势在于需要计算所有的情况，有些明显不符合的情况也需要判断。比如，所有宝石都不放，或者所有宝石都放入的情况，应该是可以直接跳过不考虑的。</p>
<p>那么，有没有比这个简单，或者说，效率更高的方法？答案就是动态规划。</p>
<p>前面提到，动态规划的核心在于找到状态及状态转移方程。我们不妨试着来找一下。</p>
<p>首先，状态很容易找到。我们先从简单的情况着手。第一次，把前一个宝石放入背包，得到最大价值20；第二次，把前两个宝石放入背包，得到最大价值30；第三次，把前三个宝石放入背包，得到最大价值32。是不是发现什么规律？对！他们可以统一表示，如果把 $maxValue[i][j]$ 定义为将前i个宝石放入容量为j的背包可以得到的最大价值，那么上述三次操作可以表示为： $maxValue[1][10]=20$ ， $maxValue[2][10]=30$ ， $maxValue[3][10]=32$ 。这些都是我们要找的状态，当然，这些也只是其中的一部分状态。</p>
<p>下面，我们找状态转移方程，即从前一个状态，转移到后一个状态所经历的变化过程。我们不妨从后往前推，找从后一个状态，转移到前一个状态经历的变化。要得到 $maxValue[3][10]$ ，有两种情况，即第三个宝石放入和不放入的情况。若第三个宝石不放入背包，则 $maxValue[3][10]=maxValue[2][10]$ ；若第三个宝石放入背包，可以得到 $maxValue[3][10]=maxValue[2][10-3]+12=maxValue[2][7]+12$ 。综上， $maxValue[3][10]=max \{ maxValue[2][10], maxValue[2][7]+12 \} $ 。问题便转换为求前一个状态 $maxValue[2][10]$ 与 $maxValue[2][7]$ 的值。接着，再经过一步一步的转换，最终化繁为简，转换到初始状态，并解决问题。</p>
<p>下面，我们用过代码实例（Java实现）来具体阐述。我们会用递归方法与非递归方法解决之，由于个人感觉递归方法较易理解，故先讲述递归方法。</p>
<h2>递归方法</h2>
<p>递归方法与分析的过程一致，从后往前推导，逐步得到最大价值。代码如下：</p>
<pre><code class="language-Java">// 返回前number个宝石放入容量为capacity的背包可以获得的最大价值
public int knapsackProblemRecursive(int[] volumes, int[] values, int number, int capacity) {
	// number从1开始，如果number为0时，可以获得的最大价值为0
	if (number == 0) return 0;
	// 判断第number个宝石是否放入
	// 第number个宝石不放入背包，计算最大价值
	int notAdded = knapsackProblemRecursive(volumes, values, number-1, capacity);
	// 第number个宝石放入背包，计算最大价值
	int added = 0;
	// 放入背包前确保有足够空间
	if (capacity &gt;= volumes[number-1]) {
		added = knapsackProblemRecursive(volumes, values, number-1, capacity-volumes[number-1]) + values[number-1];
	}
	return notAdded &gt; added ? notAdded : added;
}
</code></pre>
<h2>非递归方法</h2>
<p>非递归方法参考了Hawstein博客中的方法，使用二维数组存储各个状态下的最大价值，即局部最优解，最后得到全局最优解。代码如下：</p>
<pre><code class="language-Java">// 返回前number个宝石放入容量为capacity的背包可以获得的最大价值
public static int knapsackProblemNonRecursive(int[] volumes, int[] values, int number, int capacity) {
	// maxValues[i][j]: 前i个宝石装入剩余容量为j的背包中的最大价值
	int[][] maxValues = new int[100][100];
	for (int i = 0; i &lt;= number; i++) {
		for (int j = 0; j &lt;= capacity; j++) {
			// number从1开始，前0个宝石放入背包，最大价值均为0
			// 第i个宝石不放入背包，计算最大价值
			maxValues[i][j] = i==0 ? 0 : maxValues[i-1][j];
			// 确保有足够空间放入宝石
			if (i &gt; 0 &amp;&amp; j &gt;= volumes[i-1]) {
				// 第i个宝石放入背包，计算最大价值
				int added = maxValues[i-1][j-volumes[i-1]] + values[i-1];
				maxValues[i][j] = maxValues[i][j] &gt; added ? maxValues[i][j] : added;
			}
		}
	}
	// 返回要求计算的最大价值
	return maxValues[number][capacity];
}
</code></pre>
<h2>完全背包问题</h2>
<p>上述问题是基本的01背包问题，另一个基本的背包问题模型，是完全背包问题。完全背包问题与01背包问题的区别在于，每一种物品都有无数个，而不是只有一个。我们仍可以按照01背包问题的方法来分析，这次maxValue[i][j]是找出前i个宝石放入容量为j的背包，每个宝石可以放0个、1个、2个、3个……我们可以发现对于每一种宝石i，能够放入背包的最大量为capacity/volume[i]。于是，我们写出状态转移方程为maxValue[i][j]=max{ maxValue[i-1][j-k*volume[i]]+k*value[i] | 0 &lt;=k&lt;=capacity/volume[i] }，然后根据状态转移方程进行实现即可。</p>
<h2>多重背包问题</h2>
<p>多重背包问题与完全背包问题的不同在于前者在宝石数量上作了限制，给出每种宝石的数量n[i]。多重背包问题可以看作是完全背包问题的简化，即我们不需要计算每一种宝石最多可以放几个，而由题目给出。同样，我们给出状态转移方程maxValue[i][j]=max{ maxValue[i-1][j-k*volume[i]]+k*value[i] | 0 &lt;=k&lt;=n[i] }。</p>
<h1>参考资料</h1>
<ol>
<li><a href="https://hawstein.com/2013/03/01/dp-knapsack/">动态规划之背包问题（一）</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/13" rel="alternate"/><category term="2017"/><category term="动态规划"/><category term="算法"/><published>2023-06-28T13:55:46+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/12</id><title>区块链的共识问题</title><updated>2023-08-12T00:00:55.609289+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>迁移自老博客，发表时间：2017-04-18</p>
</blockquote>
<h1>拜占庭将军问题</h1>
<p>四位将军商讨攻打拜占庭的时机，他们中任意三人达成一致，就可以获胜。由于他们相互缺乏信任，不能共处一室，只能通过书信向其他将军发表看法，比如，在第一轮通信中，可能出现4位将军都不一样的情况。那么，要如何协调，让大家的攻打时机一致呢？在这样的情况下，如果是40人，或者更多人，如何协调呢？问题的本质是如何在一个不基于信任的网络中达成共识。</p>
<p>通过论证可以证明，在将军总数为n，其中叛国者数为m，并且n ≥ 3m+1时，该问题有解。</p>
<h1>区块链技术解决共识问题</h1>
<p>区块链通过挑选一个仲裁者行使仲裁权，来解决此问题。而为了避免因此变成中心化链，特意分开了仲裁权与仲裁者。在需要仲裁时，在所有节点中随机挑选一个节点作为仲裁者，其他节点跟随它完成记账任务。这样，所有节点保存的总账就是一致的。</p>
<p>这里的共识问题在比特币网络中的场景为，矿工在找到一个新的区块时，这个区块成为仲裁者，带头录入交易记录。</p>
<h1>可信任的区块链网络的价值</h1>
<h2>区块链技术能够降低信任风险</h2>
<p>区块链技术具有开源、透明的特性，系统的参与者能够知晓系统的运行规则。在区块链技术下，由于每个数据节点都可以验证账本内容和账本构造历史的真实性和完整性，确保交易历史是可靠的、没有被篡改的，相当于提高了系统的可追责性，降低了系统的信任风险。</p>
<h2>区块链能够驱动新型商业模式的诞生</h2>
<p>区块链技术的特点让它能够实现一些在中心化模式下难以实现的商业模式。比如在物联网产业，已经有机构提出要使用区块链技术管理上百亿个物联网设备的身份、支付和维护任务。利用区块链技术，物联网设备生产商能够及大地延长产品的生命周期和降低物联网维护的成本。</p>
<h2>区块链技术具有灵活的架构</h2>
<p>根据不同的应用场景和用户需求，区块链技术可以划分为公有链、私有链和联盟链几大类型，可根据机构的实际用途进行选择。</p>
<h2>区块链技术是实现共享金融的有利工具</h2>
<p>共享金融的本质是通过减少金融信息的不对称性，从而实现金融资源优化配置的目的，并通过严格的第三方认证和监督机制，保证交易双方权益的落实，促成交易达成。通过使用区块链技术，金融信息和金融价值能够得到更加严格的保护，能够实现更加高效、更低成本的流动，从而实现价值和信息的共享。</p>
<h2>区块链技术的开放性鼓励创新和协作</h2>
<p>通过源代码的开放和协作，区块链技术能够促进不同开发人员、研究人员以及机构间的协作，相互取长补短，从而实现更高效、更安全的解决方案。近年来，已有不少海外金融机构和商业机构尝试用区块链技术进行商业模式的改进，在中国，尽管这一技术尚未得到广泛的认知和应用，但是已经开始引起越来越广泛的重视，其影响力正在快速增强。现在区块链技术已经被视为下一代全球信用认证和价值互联网的基础协议之一，区块链技术对我国金融产业和金融体系的重要性同样不容忽视。</p>
<h1>参考资料</h1>
<ol>
<li><a href="https://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭将军问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20522513?utm_id=0">区块链与银行家</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20925427?utm_id=0">区块链的共识机制</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/12" rel="alternate"/><category term="2017"/><category term="区块链"/><category term="共识"/><published>2023-06-27T14:51:10+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/11</id><title>我的日常 TODO 记录</title><updated>2023-08-12T00:00:55.696082+00:00</updated><content type="html"><![CDATA[<p>之前一直用微信给自己发消息作为 TODO，做完就删掉。但觉得把做完的事情也记录下来，或许会更有成就感。</p>
<p>后面就用这个 Issue 记录我的日常 TODO。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/11" rel="alternate"/><category term="2023"/><category term="TODO"/><category term="记录"/><published>2023-06-26T15:05:15+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/10</id><title>为什么要写博客</title><updated>2023-08-12T00:00:55.768562+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-04-14</p>
</blockquote>
<p>曾经认为，写博客的都是大神，都好有奉献精神，愿意把自己的东西分享给大家。那时候，我忙于在知识的海洋中遨游，汲取营养，没有时间去写博客（说得像真的一样_(:3」∠)_）。但渐渐发现，我的学习模式有些问题。大多数时候，我只是急功近利地解决问题，解决完问题，就把问题放到一边，以后再遇到，仍然需要重复劳动。有些时候，会一时兴起学些感兴趣的东西，为了方便以后复习，我开始记笔记，这算是一个很大的进步了。然而，光是这样记笔记，我发现水平并没有很大的提升，或者说，我并没有深入问题的本质，在许多地方理解不够。这个时候，我似乎找到了写博客的理由。</p>
<p>整理自己的知识与思路，用自己的语言表述出来，用输出倒逼输入。我想，这就是我写博客的理由。当然，如果能与大家一起交流，深入探讨，那就更是一大幸事了。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/10" rel="alternate"/><category term="2017"/><published>2023-06-26T14:25:51+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/9</id><title>《微习惯》读书笔记</title><updated>2023-08-12T00:00:55.849176+00:00</updated><content type="html"><![CDATA[<h1>养成习惯的两种策略</h1>
<h2>动力策略</h2>
<p>主要是不断给自己打鸡血。</p>
<h3>问题</h3>
<ol>
<li>动力基于个人感受，个人感受经常变化，无法预测</li>
<li>动力会边际效应递减</li>
</ol>
<h2>意志力策略</h2>
<p>靠意志力坚持习惯，在坚持不下去的时候可以使用微习惯。</p>
<h1>养成新习惯的阻力</h1>
<ol>
<li>无法开始行动，觉得还没准备好</li>
<li>没法坚持下去</li>
</ol>
<h1>养成微习惯的八个步骤</h1>
<ol>
<li>选择一个微习惯，制定每天的计划</li>
<li>挖掘每个微习惯的内在价值</li>
<li>把微习惯纳入到日程中</li>
<li>建立回报机制</li>
<li>记录和跟踪完成情况</li>
<li>微量开始，超额完成</li>
</ol>
<blockquote>
<p>哄骗大脑，进入状态并保持，因为大脑抗拒改变，从而容易超额完成。</p>
</blockquote>
<ol start="7">
<li>服从计划，摆脱高期待值</li>
</ol>
<blockquote>
<p>摆脱高期待值，深有体会。以前会因为某些事情想做好而兴奋地睡不着。</p>
</blockquote>
<ol start="8">
<li>留意习惯养成的标志，比如到点自动想起来</li>
</ol>
<h2>步骤总结</h2>
<ol>
<li>纳入日程，记录和跟踪</li>
<li>奖励自己</li>
<li>微量开始，超额完成，摆脱高期待</li>
</ol>
<h1>我的微习惯</h1>
<ul>
<li><input disabled="" type="checkbox"> 每天早上冥想 1 分钟</li>
<li><input disabled="" type="checkbox"> 每天睡觉前做 1 个俯卧撑</li>
<li><input disabled="" type="checkbox"> 输入：每天看 5 分钟分享 或者 输出：每天写 10 个字的博客</li>
</ul>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/9" rel="alternate"/><category term="2023"/><category term="TODO"/><category term="读书笔记"/><category term="习惯"/><published>2023-06-26T09:11:49+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/8</id><title>《哲学家们都干了些什么？》读书笔记</title><updated>2023-08-12T00:00:55.949075+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>最初发在豆瓣上，搬运过来。发表时间：2022-12-21</p>
</blockquote>
<p>笛卡尔认为只有我存在是确定的，其他都值得怀疑。</p>
<p>休谟的怀疑论，怀疑因果律，进而怀疑科学。</p>
<p>康德认为世界、自由意志是物自体，我们无法认知，我们只能用理性把物自体转成自己的意识，人的理性给自然立法。</p>
<p>黑格尔用辩证法阐明矛盾是世界的本质，事物在矛盾中朝着一定方向发展，最终发展成绝对精神。</p>
<p>叔本华认为生命意志驱使万物朝着一定的方向发展，人被欲望驱使。由此发展出悲观主义，人在无法满足欲望的痛苦和满足欲望的无聊间切换。</p>
<p>尼采和叔本华类似，他提出超人理论，认为强者要承认痛苦，迎战痛苦；禁止性规定是为了保护弱者，压制强者。</p>
<p>罗素、维特根斯坦的逻辑实证主义，希望用严谨的语言表达哲学，最后失败了，说明理性根本无法担负从总体上解释世界、指导生活的任务。</p>
<p>波普尔提出证伪主义，认为可证伪的才是科学，不可证伪的问题没有意义。</p>
<p>在理性的领域里，面对“人生的意义是什么”等等形而上学问题，要么去求助心理医生，要么就没有答案了。</p>
<p>下面又回到笛卡尔的“我思故我在”。</p>
<p>先是萨特的存在主义，认为人有自由意志，有选择的自由，即使不做出选择，也是一种自由；但同时，自由越多，责任越大。</p>
<p>加缪认为人生是荒诞的，没有意义，生命可能戛然而止，而不会有高潮结尾。</p>
<p>最后作者的观点：</p>
<ol>
<li>
<p>对于客观世界，最好的研究方法是“基于经验主义和实用主义的、可证伪的理论”。说白了，就是科学</p>
</li>
<li>
<p>世界的本质就是我的信念。我相信世界的本质是什么，它就是什么</p>
</li>
<li>
<p>人生意义没有固定答案，也因为没有固定答案，世界才更美好。思考人生意义最有效的办法，就是逼迫自己直面死亡。为什么活着，为什么不立刻自杀？</p>
</li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/8" rel="alternate"/><category term="哲学"/><category term="2022"/><category term="读书笔记"/><published>2023-06-26T01:46:23+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/7</id><title>“人生意义”观点收集</title><updated>2023-08-12T00:00:56.027283+00:00</updated><content type="html"><![CDATA[<p>从很早就开始思考人生意义，到目前为止得出的结论基本是：人生无意义。但无意义≠不值得过，个人可以选择合适的意义并活下去。
于是开个 Issue 记录下各种人生意义的观点，也算阶段性总结。</p>
<p>PS：这个 Issue 的 WIP 标签估计是去不掉的...</p>
<p>李银河的观点，对美的享用</p>
<p>弗洛伊德</p>
<p>阿德勒</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/7" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="人生意义"/><published>2023-06-25T16:39:40+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/6</id><title>博客折腾记录</title><updated>2023-08-12T00:00:56.199974+00:00</updated><content type="html"><![CDATA[<h1>目标</h1>
<p>梳理下自己记录博客的历程，明确记录的长期目标与工具。</p>
<h1>印象笔记</h1>
<h1>OneNote</h1>
<h1>博客</h1>
<h1>语雀</h1>
<h1>flomo + 博客</h1>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/6" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="总结"/><published>2023-06-25T15:16:59+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/5</id><title>记录我的冥想</title><updated>2023-08-12T00:00:56.290976+00:00</updated><content type="html"><![CDATA[<h1>目标</h1>
<p>自动记录冥想，开始时间、结束时间、此刻的想法，看见自己的成长。</p>
<h1>任务</h1>
<ul>
<li><input disabled="" type="checkbox"> 完成一个自动记录冥想时间、冥想想法的工具🛠️</li>
</ul>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/5" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="冥想"/><category term="TODO"/><published>2023-06-25T15:14:13+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/4</id><title>权限模型介绍</title><updated>2023-08-12T00:00:56.378381+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<h1>目标</h1>
<h1>权限模型</h1>
<h2>ACL</h2>
<h2>MAC</h2>
<h2>DAC</h2>
<h2>RBAC</h2>
<h2>ABAC</h2>
<h2>NGAC</h2>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/4" rel="alternate"/><category term="技术"/><category term="WIP"/><category term="2023"/><category term="权限"/><published>2023-06-25T14:18:54+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/3</id><title>利用 Github Issues 写博客</title><updated>2023-08-12T00:00:56.459113+00:00</updated><content type="html"><![CDATA[<h1>1 背景</h1>
<p>之前使用 Hexo 搭建过自己的博客 <a href="https://zzy131250.github.io">zzy131250</a>，用的是 Github Pages，主要目标是通过写作积累输出。
在工作后，写作比较少，加之更换电脑，原来本地的博客源码都没了。最近心血来潮，打算重新开始写作，但又懒得再去折腾 Hexo 博客，所以尝试使用 Github Issues 来写博客。
Github Issues 写博客配置简单，非常友好，这里记录下配置过程。</p>
<h2>1.1 优势</h2>
<ol>
<li>免费，不需要服务器或域名</li>
<li>自带评论功能</li>
<li>可以通过手机编辑和发布博客</li>
<li>可以通过 Actions 自动化</li>
</ol>
<h2>1.2 劣势</h2>
<ol>
<li>Github 访问不稳定，有时候需要科学上网</li>
</ol>
<h1>2 目标</h1>
<ol>
<li>使用 Github Issues 写博客，支持添加标签</li>
<li>通过 Github Actions 自动生成 README 和 RSS 订阅</li>
</ol>
<h1>3 流程</h1>
<h2>3.1 新建项目</h2>
<h2>3.2 编辑并上传文件</h2>
<h3>3.2.1 问题：本地 Push 代码到 Github 提示无法使用密码</h3>
<h2>3.3 配置 Github Actions</h2>
<h3>3.3.1 问题：Actions 运行报错，Push 代码报 403</h3>
<h1>4 效果</h1>
<h2>4.1 Issues</h2>
<img width="1245" alt="image" src="https://github.com/zzy131250/gitblog/assets/7437470/b8a3750a-2d5b-4d1c-942f-931c12b3de01">
<h2>4.2 Actions</h2>
<img width="1433" alt="image" src="https://github.com/zzy131250/gitblog/assets/7437470/d895db8d-1875-42a6-adae-cc9c32053e2b">
<h2>4.3 README</h2>
<img width="924" alt="image" src="https://github.com/zzy131250/gitblog/assets/7437470/d03aae65-b15f-4048-8135-b82bdc8d369f">
<h1>5 参考</h1>
<ol>
<li><a href="https://github.com/yihong0618/gitblog">gitblog</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1708679340950201611&amp;wfr=spider&amp;for=pc">使用 GitHub Issues 来写博客，真香</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/3" rel="alternate"/><category term="技术"/><category term="WIP"/><category term="2023"/><published>2023-06-25T08:51:45+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/2</id><title>谈谈蓝牙4.0（BLE）模块与安卓的数据交互</title><updated>2023-08-12T00:00:56.542844+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>迁移自老博客，发表时间：2017-04-17</p>
</blockquote>
<p>开发蓝牙4.0也快两个月了，给我的感受还是颇多的。</p>
<p>我开发的是与TI的蓝牙模块CC2540交互的安卓端蓝牙软件，对于安卓都不是很熟悉的我，是一个不小的挑战。</p>
<p>我用的是google官方的源码，它本身把很多基本框架都搭好了。直接就能运行，当然前提是在Android Studio上，如果是Eclipse上还需要稍作改动。</p>
<p>我们先来看下代码。它主要有两个Avtivity和一个Service组成，顾名思义，两个Activity的用途分别为设备扫描与设备管理。</p>
<p>这里我不准备介绍基本的BLE知识（自行百度即可），我只是说一下一些需要注意的地方，特别是我百度不到的好多东西，希望跟大家分享一下。</p>
<p>一开始的软件已经可以查看Service和Characteristic的UUID，不过只能接收消息，原因大概是这个Sample当初设计的时候就只负责接收。当然要发送也简单，只要在BluetoothLeService中加writeCharacteristic方法。</p>
<pre><code class="language-Java">public boolean writeCharacteristic(BluetoothGattCharacteristic charac，String message){
    // check if mBluetoothGatt is available
    if (mBluetoothGatt == null) {
        Log.e(TAG, &quot;lost connection&quot;);
        return false;
    }
    charac.setValue(message.getBytes());
    boolean status = mBluetoothGatt.writeCharacteristic(charac);
    return status;
}
</code></pre>
<p>写数据比较简单，直接调用这个方法即可。当然，这里也有个陷阱，我们发现，如果你在CC2540中定义了Byte字节的长度，那么在charac.setValue()中的数组长度要跟其相同，不然模块是收不到的。</p>
<p>我们发现在很多地方都用到了BluetoothGattCharacteristic这个类，即特性，BLE就是靠改变特性值来传递数据的，那么，这些BluetoothGattCharacteristic是从哪里得到的呢？我们知道，BluetoothGattCharacteristic是BluetoothGattService中的属性，我们要得到BluetoothGattCharacteristic，就要先得到BluetoothGattService。那要怎么样得到BluetoothGattService呢？</p>
<pre><code class="language-Java">public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
    String intentAction;
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        intentAction = ACTION_GATT_CONNECTED;
        mConnectionState = STATE_CONNECTED;
        broadcastUpdate(intentAction);
        Log.i(TAG, &quot;Connected to GATT server.&quot;);
        // Attempts to discover services after successful connection.
        Log.i(TAG, &quot;Attempting to start service discovery:&quot; + mBluetoothGatt.discoverServices());
    } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
        intentAction = ACTION_GATT_DISCONNECTED;
        mConnectionState = STATE_DISCONNECTED;
        Log.i(TAG, &quot;Disconnected from GATT server.&quot;);
        broadcastUpdate(intentAction);
    }
}
</code></pre>
<p>这里先简单见一下回调，开发过安卓的朋友们应该了解，在安卓开发中，某个动作可能会出发后续的动作，这个被触发的动作就是回调。这里onConnectionStateChange函数就是在连接状态改变后会触发的回调，我们看到mBluetoothGatt.discoverServices()这里执行了发现服务的方法，那么在发现完服务呢？没错，它同样触发回调。</p>
<pre><code class="language-Java">public void onServicesDiscovered(BluetoothGatt gatt, int status) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
        broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);
    } else { 
        Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status);
    }
}
</code></pre>
<p>它会调用onServicesDiscovered(BluetoothGatt gatt, int status)方法，在这里它会发出一个广播broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED)。值得注意的是，在这里，BluetoothLeService与DeviceControlActivity交互的方式是广播。我们看到broadcastUpdate方法，在BluetoothLeService中。</p>
<pre><code class="language-Java">private void broadcastUpdate(final String action) {
    final Intent intent = new Intent(action);
    sendBroadcast(intent);
}
private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) {
    final Intent intent = new Intent(action);
    final byte[] data = characteristic.getValue();
    if (data != null &amp;&amp; data.length &gt; 0) {
        final StringBuilder stringBuilder = new StringBuilder(data.length);
        for(byte byteChar : data) {
            stringBuilder.append(String.format(&quot;%02X &quot;, byteChar));
        }
        intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString());
    }
    sendBroadcast(intent);
}
</code></pre>
<p>这里有两个broadcastUpdate，但效果是相似的，他们都调用sendBroadcast(intent)，至于sendBroadcast方法，就是底层的一些实现了，这里不用管他。我们知道了，在发现了服务之后，BluetoothLeService就sendBroadcast。那么，这个Broadcast传到哪里呢？答案是这里。</p>
<pre><code class="language-Java">private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        if (BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
            mBluetoothLeService.getSupportedGattServices()；
        }
    }
}
</code></pre>
<p>在DeviceControlActivity中有个onReceive方法，就是接受广播的地方。他通过参数intent的值判断广播的内容。ACTION_GATT_SERVICES_DISCOVERED这个参数表示发现服务。这里再调用getSupportedGattServices就可以获得服务啦。然后特性什么的就都知道了。</p>
<p>目前为止我们解决了往特性里写值的问题，那么，如何读取模块发来的消息呢？我们来说说具体的接收流程。</p>
<p>我们首先要明确的是，安卓端接收消息的被动的，它只能被动地告知要接收消息，而告诉他的人就是模块。这里我们说一下特性，特性有自身的一些属性，其实一个服务的每个特性都有自己独立的作用，这个可以自己定义，主要有可写，可读，还有专门用来通知的，即Notification，在模块改变了特性值，他得让手机知道，那么他就通过有Notification功能的特性发出通知。那么，如果模块的Service有好多特性，他怎么知道往哪个特性中发通知呢？所以，我们必须先告知模块我们通过哪个特性接收通知，代码如下。</p>
<pre><code class="language-Java">public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {
    if (mBluetoothAdapter == null || mBluetoothGatt == null) {
        Log.w(TAG, &quot;BluetoothAdapter not initialized&quot;);
        return;
    }
    BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(DeviceControlActivity.NotificationCharacDescripter));
    descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
    mBluetoothGatt.writeDescriptor(descriptor);  
    mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
}
</code></pre>
<p>这里设置了BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE，相当于告知模块，我们从这个特性接受通知。然后，如果模块改变了其他特性值，他就会通过这个特性通知我们去读取。</p>
<p>在我们接收到通知后，安卓触发回调onCharacteristicChanged，并广播通知DeviceControlActivity去接收消息。</p>
<p>这里我们再看一下broadcastUpdate函数，这里调用的是private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic)。</p>
<pre><code class="language-Java">private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) {
    final Intent intent = new Intent(action);
    final byte[] data = characteristic.getValue();
    if (data != null &amp;&amp; data.length &gt; 0) {
        final StringBuilder stringBuilder = new StringBuilder(data.length);
        for(byte byteChar : data) {
            stringBuilder.append(String.format(&quot;%02X &quot;, byteChar));
        }
        intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString());
    }
    sendBroadcast(intent);
}
</code></pre>
<p>上面的代码中BluetoothLeService把接收的数据保存到了EXTRA_DATA里面。</p>
<pre><code class="language-Java">if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) {
    intent.getStringExtra(BluetoothLeService.EXTRA_DATA);
}
</code></pre>
<p>DeviceControlActivity再通过这里接收广播并取出数据，完成数据接收。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/2" rel="alternate"/><category term="技术"/><category term="Android"/><category term="BLE"/><category term="2017"/><published>2023-06-25T08:30:50+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/1</id><title>Github Issues 第一篇博客</title><updated>2023-08-12T00:00:56.643736+00:00</updated><content type="html"><![CDATA[<p>准备开始尝试使用 Github Issue 写博客，会慢慢把 ziazhou.com 上的博客迁移过来。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/1" rel="alternate"/><category term="2023"/><published>2023-06-25T03:52:09+00:00</published></entry></feed>