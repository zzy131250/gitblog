<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/zzy131250/gitblog</id><title>RSS feed of zzy131250's gitblog</title><updated>2023-07-02T13:54:42.449483+00:00</updated><author><name>zzy131250</name><email>zia.zhou@pm.me</email></author><link href="https://github.com/zzy131250/gitblog"/><link href="https://raw.githubusercontent.com/zzy131250/gitblog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><entry><id>https://github.com/zzy131250/gitblog/issues/29</id><title>KMP 算法</title><updated>2023-07-02T13:54:42.774692+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2020-02-01</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/29" rel="alternate"/><category term="WIP"/><category term="算法"/><category term="字符串匹配"/><category term="2020"/><published>2023-06-30T01:46:47+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/28</id><title>IPTables 学习实践</title><updated>2023-07-02T13:54:42.896572+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2019-06-12</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/28" rel="alternate"/><category term="WIP"/><category term="网络"/><category term="IPTables"/><category term="2019"/><published>2023-06-30T01:45:40+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/27</id><title>做一只爬虫需要考虑的</title><updated>2023-07-02T13:54:43.015526+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2019-04-10</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/27" rel="alternate"/><category term="WIP"/><category term="爬虫"/><category term="2019"/><published>2023-06-29T15:01:03+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/26</id><title>JDK 动态代理</title><updated>2023-07-02T13:54:43.115790+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2018-09-02</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/26" rel="alternate"/><category term="WIP"/><category term="Java"/><category term="动态代理"/><category term="2018"/><published>2023-06-29T14:02:30+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/25</id><title>技术脑图整理</title><updated>2023-07-02T13:54:43.232249+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2018-02-23</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/25" rel="alternate"/><category term="WIP"/><category term="读书笔记"/><category term="2018"/><published>2023-06-29T13:57:20+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/24</id><title>马尔科夫模型</title><updated>2023-07-02T13:54:43.338957+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-09-07</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/24" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="NLP"/><published>2023-06-29T13:55:55+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/23</id><title>反向传播</title><updated>2023-07-02T13:54:43.445946+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-08-19</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/23" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="深度学习"/><published>2023-06-29T13:54:42+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/22</id><title>动态规划（二）——最长递增子序列（LIS）</title><updated>2023-07-02T13:54:43.548373+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-08-06</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/22" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="动态规划"/><category term="算法"/><published>2023-06-29T13:53:23+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/21</id><title>从最小二乘法到梯度下降法（二）</title><updated>2023-07-02T13:54:43.655181+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-28</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/21" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="优化"/><category term="深度学习"/><published>2023-06-29T05:16:25+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/20</id><title>从最小二乘法到梯度下降法（一）</title><updated>2023-07-02T13:54:43.759247+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-24</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/20" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="优化"/><category term="深度学习"/><published>2023-06-29T01:49:43+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/19</id><title>记一次异常数据过滤算法的优化</title><updated>2023-07-02T13:54:43.901484+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-13</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/19" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="算法"/><category term="优化"/><published>2023-06-29T01:48:25+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/18</id><title>布隆过滤器</title><updated>2023-07-02T13:54:44.009637+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-09</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/18" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="算法"/><category term="哈希"/><published>2023-06-28T15:06:02+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/17</id><title>Python 库推荐</title><updated>2023-07-02T13:54:44.130889+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-02</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/17" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="Python"/><category term="库"/><published>2023-06-28T15:05:03+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/16</id><title>IO 复用</title><updated>2023-07-02T13:54:44.245161+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-07-01</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/16" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="IO"/><category term="异步"/><published>2023-06-28T14:52:23+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/15</id><title>目标遐想</title><updated>2023-07-02T13:54:44.351815+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-05-14</p>
</blockquote>
<p>一直认为自己是一个目标明确的人，但有时候还是会对目标有些疑惑。我想，不如在这里记录下自己的思考，让头脑不再模糊。</p>
<p>记得在刚进大学那会儿，觉得世界好大，觉得自己充满好奇，充满活力，什么都想尝试。那时候报了好多社团，迫切地想要拥抱世界，拥抱大学。然而，接下来的时间，我经历了一段迷茫期，觉得对什么都提不起兴趣，觉得人生大概就这样了。我突然很怀念高中那段时光，虽然那时候很累、很苦，但是有目标，有奋斗的动力，愿意付出所有。有朋友说，他不喜欢高中死读书的人，这些人不有趣，不懂得享受生活。但我的看法是，既然有目标，有精力，就为了目标倾尽全力，为了以后不后悔。这在某种程度上也算把自己感动，至少自己不会觉得可惜。</p>
<p>所以，我想我大概是缺了一个目标。</p>
<p>我可能是目的论的拥趸，觉得没有目标，就没有了意义。说到意义，或许，人生本来就没有意义，与世无争也是一种选择。但我总觉得，我拥有了只会有一次的生命，如果不好好珍惜，那该有多可惜啊！</p>
<p>那么，我该把什么当作目标呢？</p>
<p>共产主义的目标是为了全人类的解放，这个目标对我来说，太大，不好把握。功利主义的目标是为最多数人谋取最大利益，对于个人来说，功利主义免不了自私的嫌疑，我不敢苟同。自由主义追求个人的自由，我想，这就是我想要的。</p>
<p>关于自由。这里的自由，是很高的要求，是由自己的理性制定的准则，不是迫于压力，或是被欲望指使。在某种程度上，自由即自律。过去，我也尽量做到自律，但总是容易迷失，不知道为何自律，现在，我明确了目的。</p>
<p>另外，我还想把追求幸福当作个人的目标。当然，这里的幸福，也是种局限的幸福。</p>
<p>首先，它是一种长远的幸福。如果把人生当作一次登山，那么，登上山顶的那一刻，就是最幸福的时刻。但是，你会想让那个时刻在何时出现呢？我们来设想一下，如果那一刻出现在你20岁的时候，那肯定有很多人夸你年少成才，你可以获得极大的荣耀。可是，那之后呢？那之后，你的人生会持续走下坡。相反，如果那个时刻出现在你40岁的时刻，那么在你40岁之前，你的人生都是一个上坡，你会持续的体会到取得成就的幸福感。即使在以后慢慢下坡，你也有理由说服自己，该退休了，这是理所当然的。当然，如果你的人生，不止一次上下坡，而是像过山车一样，上下起伏，我认为那样也是很好的，因为至少有一半时间是上坡。</p>
<p>其次，它是一种高层次的幸福。根据马斯洛的需求层次理论，高层次的需求包含社交需要、尊重需要和自我实现的需要。同样，我所追求的幸福是人际关系良好、自我尊重、自我实现时的幸福。</p>
<p>这段时间有一首很火的小诗，说每个人都有自己的时区，生命就是等待正确的行动时机。我的看法是，光等待是不够的，要行动起来，并等待时机，不然这只会是那些站在原地却幻想成功的人的鸡汤。我喜欢一句相似的话，“但行好事，莫问前程。”我想，这更能催人奋进，也更可能让人获得幸福。</p>
<p>日剧《四重奏》里面，有朱有句台词，“人生轻而易举”。每个人有每个人过自己人生的权利，但是，我不要我的人生轻而易举。</p>
<p>最后，正好趁着母亲节，祝妈妈节日快乐！</p>
<p>2017.05.14 南京</p>
<h1>更新</h1>
<p>一直觉得，似乎自由与幸福就可以是我追求的全部，但最近一些事，似乎一直在印证，还有些东西，也是需要追求的。</p>
<p>这个东西，我觉得是责任。</p>
<p>自由是“从心所欲，不逾矩”，而责任，可以归为“矩”的一部分。从这方面看，目标的排序应该是责任、自由、幸福。</p>
<p>如果不考虑责任，或许会更加幸福。但是，这样的幸福，会变成“不能承受的生命之轻”。不考虑责任，只求自由和幸福，显得自私。</p>
<p>适逢海军成立70周年，祝人民海军生日快乐！</p>
<p>2019.04.23 南京</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/15" rel="alternate"/><category term="2017"/><category term="目标"/><published>2023-06-28T14:11:48+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/14</id><title>Paxos 算法学习笔记</title><updated>2023-07-02T13:54:44.465457+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-04-30</p>
</blockquote>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/14" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="算法"/><category term="Paxos"/><category term="分布式"/><published>2023-06-28T14:03:53+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/13</id><title>动态规划（一）——背包问题</title><updated>2023-07-02T13:54:44.586130+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-04-23</p>
</blockquote>
<h1>简介</h1>
<p>动态规划是一种特殊的算法技巧，它通过把原问题分解为相对简单的子问题的方式来求解复杂问题。</p>
<p>动态规划中，子问题的解被称为状态，状态之间的转换称作状态转换方程。动态规划的核心就是找到状态及状态转换方程。</p>
<p>下面通过动态规划的实例——背包问题，来阐述其方法。</p>
<h1>背包问题</h1>
<h2>问题简述</h2>
<p>有一个人，他背上一个背包去森林里寻宝，发现一堆宝石，但是他的背包容量有限，无法一次装下所有宝石。假设背包容量为capacity，如果把宝石编号为1，2，…，n，宝石的体积分别为volume[0]，volume[1]，…，volume[n-1]，宝石的价值依次为value[0]，value[1]，…，value[n-1]。现在问题来了，这个人如何挑选宝石放进背包，可以使自己获得最大利益？</p>
<h2>问题分析</h2>
<p>这是一个典型的动态规划问题。我们不妨先来假设一下，假设背包容量为10，宝石的体积为5，4，3，宝石的价值为20，10，12。</p>
<p>如果什么都不想，直接排列组合，也是可以的。对于每一个宝石，有两种选择，放入背包，或者不放入背包。这样一共有8种情况，只需再考虑每种情况下背包的容量问题，然后得出最大价值即可。</p>
<p>这种方法的劣势在于需要计算所有的情况，有些明显不符合的情况也需要判断。比如，所有宝石都不放，或者所有宝石都放入的情况，应该是可以直接跳过不考虑的。</p>
<p>那么，有没有比这个简单，或者说，效率更高的方法？答案就是动态规划。</p>
<p>前面提到，动态规划的核心在于找到状态及状态转移方程。我们不妨试着来找一下。</p>
<p>首先，状态很容易找到。我们先从简单的情况着手。第一次，把前一个宝石放入背包，得到最大价值20；第二次，把前两个宝石放入背包，得到最大价值30；第三次，把前三个宝石放入背包，得到最大价值32。是不是发现什么规律？对！他们可以统一表示，如果把maxValue[i][j]定义为将前i个宝石放入容量为j的背包可以得到的最大价值，那么上述三次操作可以表示为：maxValue[1][10]=20，maxValue[2][10]=30，maxValue[3][10]=32。这些都是我们要找的状态，当然，这些也只是其中的一部分状态。</p>
<p>下面，我们找状态转移方程，即从前一个状态，转移到后一个状态所经历的变化过程。我们不妨从后往前推，找从后一个状态，转移到前一个状态经历的变化。要得到maxValue[3][10]，有两种情况，即第三个宝石放入和不放入的情况。若第三个宝石不放入背包，则maxValue[3][10]=maxValue[2][10]；若第三个宝石放入背包，可以得到maxValue[3][10]=maxValue[2][10-3]+12=maxValue[2][7]+12。综上，maxValue[3][10]=max{ maxValue[2][10], maxValue[2][7]+12 }。问题便转换为求前一个状态maxValue[2][10]与maxValue[2][7]的值。接着，再经过一步一步的转换，最终化繁为简，转换到初始状态，并解决问题。</p>
<p>下面，我们用过代码实例（Java实现）来具体阐述。我们会用递归方法与非递归方法解决之，由于个人感觉递归方法较易理解，故先讲述递归方法。</p>
<h2>递归方法</h2>
<p>递归方法与分析的过程一致，从后往前推导，逐步得到最大价值。代码如下：</p>
<pre><code class="language-Java">
</code></pre>
<h2>非递归方法</h2>
<p>非递归方法参考了Hawstein博客中的方法，使用二维数组存储各个状态下的最大价值，即局部最优解，最后得到全局最优解。代码如下：</p>
<pre><code class="language-Java">
</code></pre>
<h2>完全背包问题</h2>
<p>上述问题是基本的01背包问题，另一个基本的背包问题模型，是完全背包问题。完全背包问题与01背包问题的区别在于，每一种物品都有无数个，而不是只有一个。我们仍可以按照01背包问题的方法来分析，这次maxValue[i][j]是找出前i个宝石放入容量为j的背包，每个宝石可以放0个、1个、2个、3个……我们可以发现对于每一种宝石i，能够放入背包的最大量为capacity/volume[i]。于是，我们写出状态转移方程为maxValue[i][j]=max{ maxValue[i-1][j-k<em>volume[i]]+k</em>value[i] | 0 &lt;=k&lt;=capacity/volume[i] }，然后根据状态转移方程进行实现即可。</p>
<h2>多重背包问题</h2>
<p>多重背包问题与完全背包问题的不同在于前者在宝石数量上作了限制，给出每种宝石的数量n[i]。多重背包问题可以看作是完全背包问题的简化，即我们不需要计算每一种宝石最多可以放几个，而由题目给出。同样，我们给出状态转移方程maxValue[i][j]=max{ maxValue[i-1][j-k<em>volume[i]]+k</em>value[i] | 0 &lt;=k&lt;=n[i] }。</p>
<h1>参考资料</h1>
<ol>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/13" rel="alternate"/><category term="WIP"/><category term="2017"/><category term="动态规划"/><category term="算法"/><published>2023-06-28T13:55:46+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/12</id><title>区块链的共识问题</title><updated>2023-07-02T13:54:44.706779+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>迁移自老博客，发表时间：2017-04-18</p>
</blockquote>
<h1>拜占庭将军问题</h1>
<p>四位将军商讨攻打拜占庭的时机，他们中任意三人达成一致，就可以获胜。由于他们相互缺乏信任，不能共处一室，只能通过书信向其他将军发表看法，比如，在第一轮通信中，可能出现4位将军都不一样的情况。那么，要如何协调，让大家的攻打时机一致呢？在这样的情况下，如果是40人，或者更多人，如何协调呢？问题的本质是如何在一个不基于信任的网络中达成共识。</p>
<p>通过论证可以证明，在将军总数为n，其中叛国者数为m，并且n ≥ 3m+1时，该问题有解。</p>
<h1>区块链技术解决共识问题</h1>
<p>区块链通过挑选一个仲裁者行使仲裁权，来解决此问题。而为了避免因此变成中心化链，特意分开了仲裁权与仲裁者。在需要仲裁时，在所有节点中随机挑选一个节点作为仲裁者，其他节点跟随它完成记账任务。这样，所有节点保存的总账就是一致的。</p>
<p>这里的共识问题在比特币网络中的场景为，矿工在找到一个新的区块时，这个区块成为仲裁者，带头录入交易记录。</p>
<h1>可信任的区块链网络的价值</h1>
<h2>区块链技术能够降低信任风险</h2>
<p>区块链技术具有开源、透明的特性，系统的参与者能够知晓系统的运行规则。在区块链技术下，由于每个数据节点都可以验证账本内容和账本构造历史的真实性和完整性，确保交易历史是可靠的、没有被篡改的，相当于提高了系统的可追责性，降低了系统的信任风险。</p>
<h2>区块链能够驱动新型商业模式的诞生</h2>
<p>区块链技术的特点让它能够实现一些在中心化模式下难以实现的商业模式。比如在物联网产业，已经有机构提出要使用区块链技术管理上百亿个物联网设备的身份、支付和维护任务。利用区块链技术，物联网设备生产商能够及大地延长产品的生命周期和降低物联网维护的成本。</p>
<h2>区块链技术具有灵活的架构</h2>
<p>根据不同的应用场景和用户需求，区块链技术可以划分为公有链、私有链和联盟链几大类型，可根据机构的实际用途进行选择。</p>
<h2>区块链技术是实现共享金融的有利工具</h2>
<p>共享金融的本质是通过减少金融信息的不对称性，从而实现金融资源优化配置的目的，并通过严格的第三方认证和监督机制，保证交易双方权益的落实，促成交易达成。通过使用区块链技术，金融信息和金融价值能够得到更加严格的保护，能够实现更加高效、更低成本的流动，从而实现价值和信息的共享。</p>
<h2>区块链技术的开放性鼓励创新和协作</h2>
<p>通过源代码的开放和协作，区块链技术能够促进不同开发人员、研究人员以及机构间的协作，相互取长补短，从而实现更高效、更安全的解决方案。近年来，已有不少海外金融机构和商业机构尝试用区块链技术进行商业模式的改进，在中国，尽管这一技术尚未得到广泛的认知和应用，但是已经开始引起越来越广泛的重视，其影响力正在快速增强。现在区块链技术已经被视为下一代全球信用认证和价值互联网的基础协议之一，区块链技术对我国金融产业和金融体系的重要性同样不容忽视。</p>
<h1>参考资料</h1>
<ol>
<li><a href="https://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭将军问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20522513?utm_id=0">区块链与银行家</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20925427?utm_id=0">区块链的共识机制</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/12" rel="alternate"/><category term="2017"/><category term="区块链"/><category term="共识"/><published>2023-06-27T14:51:10+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/11</id><title>我的日常 TODO 记录</title><updated>2023-07-02T13:54:44.823175+00:00</updated><content type="html"><![CDATA[<p>之前一直用微信给自己发消息作为 TODO，做完就删掉。但觉得把做完的事情也记录下来，或许会更有成就感。</p>
<p>后面就用这个 Issue 记录我的日常 TODO。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/11" rel="alternate"/><category term="2023"/><category term="TODO"/><category term="记录"/><published>2023-06-26T15:05:15+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/10</id><title>为什么要写博客</title><updated>2023-07-02T13:54:44.972920+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>搬运自老博客，发表时间：2017-04-14</p>
</blockquote>
<p>曾经认为，写博客的都是大神，都好有奉献精神，愿意把自己的东西分享给大家。那时候，我忙于在知识的海洋中遨游，汲取营养，没有时间去写博客（说得像真的一样_(:3」∠)_）。但渐渐发现，我的学习模式有些问题。大多数时候，我只是急功近利地解决问题，解决完问题，就把问题放到一边，以后再遇到，仍然需要重复劳动。有些时候，会一时兴起学些感兴趣的东西，为了方便以后复习，我开始记笔记，这算是一个很大的进步了。然而，光是这样记笔记，我发现水平并没有很大的提升，或者说，我并没有深入问题的本质，在许多地方理解不够。这个时候，我似乎找到了写博客的理由。</p>
<p>整理自己的知识与思路，用自己的语言表述出来，用输出倒逼输入。我想，这就是我写博客的理由。当然，如果能与大家一起交流，深入探讨，那就更是一大幸事了。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/10" rel="alternate"/><category term="2017"/><published>2023-06-26T14:25:51+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/9</id><title>《微习惯》读书笔记</title><updated>2023-07-02T13:54:45.086368+00:00</updated><content type="html"><![CDATA[<h1>养成习惯的两种策略</h1>
<h2>动力策略</h2>
<p>主要是不断给自己打鸡血。</p>
<h3>问题</h3>
<ol>
<li>动力基于个人感受，个人感受经常变化，无法预测</li>
<li>动力会边际效应递减</li>
</ol>
<h2>意志力策略</h2>
<p>靠意志力坚持习惯，在坚持不下去的时候可以使用微习惯。</p>
<h1>养成新习惯的阻力</h1>
<ol>
<li>无法开始行动，觉得还没准备好</li>
<li>没法坚持下去</li>
</ol>
<h1>养成微习惯的八个步骤</h1>
<ol>
<li>选择一个微习惯，制定每天的计划</li>
<li>挖掘每个微习惯的内在价值</li>
<li>把微习惯纳入到日程中</li>
<li>建立回报机制</li>
<li>记录和跟踪完成情况</li>
<li>微量开始，超额完成</li>
</ol>
<blockquote>
<p>哄骗大脑，进入状态并保持，因为大脑抗拒改变，从而容易超额完成。</p>
</blockquote>
<ol start="7">
<li>服从计划，摆脱高期待值</li>
</ol>
<blockquote>
<p>摆脱高期待值，深有体会。以前会因为某些事情想做好而兴奋地睡不着。</p>
</blockquote>
<ol start="8">
<li>留意习惯养成的标志，比如到点自动想起来</li>
</ol>
<h2>步骤总结</h2>
<ol>
<li>纳入日程，记录和跟踪</li>
<li>奖励自己</li>
<li>微量开始，超额完成，摆脱高期待</li>
</ol>
<h1>我的微习惯</h1>
<ul>
<li><input disabled="" type="checkbox"> 每天早上冥想 1 分钟</li>
<li><input disabled="" type="checkbox"> 每天睡觉前做 1 个俯卧撑</li>
<li><input disabled="" type="checkbox"> 每天在地铁上写 10 个字的博客</li>
</ul>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/9" rel="alternate"/><category term="2023"/><category term="TODO"/><category term="读书笔记"/><category term="习惯"/><published>2023-06-26T09:11:49+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/8</id><title>《哲学家们都干了些什么？》读书笔记</title><updated>2023-07-02T13:54:45.232868+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>最初发在豆瓣上，搬运过来。发表时间：2022-12-21</p>
</blockquote>
<p>笛卡尔认为只有我存在是确定的，其他都值得怀疑。</p>
<p>休谟的怀疑论，怀疑因果律，进而怀疑科学。</p>
<p>康德认为世界、自由意志是物自体，我们无法认知，我们只能用理性把物自体转成自己的意识，人的理性给自然立法。</p>
<p>黑格尔用辩证法阐明矛盾是世界的本质，事物在矛盾中朝着一定方向发展，最终发展成绝对精神。</p>
<p>叔本华认为生命意志驱使万物朝着一定的方向发展，人被欲望驱使。由此发展出悲观主义，人在无法满足欲望的痛苦和满足欲望的无聊间切换。</p>
<p>尼采和叔本华类似，他提出超人理论，认为强者要承认痛苦，迎战痛苦；禁止性规定是为了保护弱者，压制强者。</p>
<p>罗素、维特根斯坦的逻辑实证主义，希望用严谨的语言表达哲学，最后失败了，说明理性根本无法担负从总体上解释世界、指导生活的任务。</p>
<p>波普尔提出证伪主义，认为可证伪的才是科学，不可证伪的问题没有意义。</p>
<p>在理性的领域里，面对“人生的意义是什么”等等形而上学问题，要么去求助心理医生，要么就没有答案了。</p>
<p>下面又回到笛卡尔的“我思故我在”。</p>
<p>先是萨特的存在主义，认为人有自由意志，有选择的自由，即使不做出选择，也是一种自由；但同时，自由越多，责任越大。</p>
<p>加缪认为人生是荒诞的，没有意义，生命可能戛然而止，而不会有高潮结尾。</p>
<p>最后作者的观点：</p>
<ol>
<li>
<p>对于客观世界，最好的研究方法是“基于经验主义和实用主义的、可证伪的理论”。说白了，就是科学</p>
</li>
<li>
<p>世界的本质就是我的信念。我相信世界的本质是什么，它就是什么</p>
</li>
<li>
<p>人生意义没有固定答案，也因为没有固定答案，世界才更美好。思考人生意义最有效的办法，就是逼迫自己直面死亡。为什么活着，为什么不立刻自杀？</p>
</li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/8" rel="alternate"/><category term="哲学"/><category term="2022"/><category term="读书笔记"/><published>2023-06-26T01:46:23+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/7</id><title>“人生意义”观点收集</title><updated>2023-07-02T13:54:45.367545+00:00</updated><content type="html"><![CDATA[<h1>前言</h1>
<p>从很早就开始思考人生意义，到目前为止得出的结论基本是：人生无意义。但无意义≠不值得过，个人可以选择合适的意义并活下去。
于是开个 Issue 记录下各种人生意义的观点，也算阶段性总结。</p>
<p>PS：这个 Issue 的 WIP 标签估计是去不掉的...</p>
<p>李银河的观点，对美的享用</p>
<p>人生不如意十之八九，不思八九，常念一二</p>
<h1>2023-06-26更新</h1>
<p>在《哲学家们都干了些什么？》的最后，作者的观点是思考死亡，想清楚为什么不自杀，就能想清楚人生意义。
于是去看了欧文·亚隆的《直视骄阳》，里面的观点是</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/7" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="人生意义"/><published>2023-06-25T16:39:40+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/6</id><title>博客折腾记录</title><updated>2023-07-02T13:54:45.466498+00:00</updated><content type="html"><![CDATA[<h1>目标</h1>
<p>梳理下自己记录博客的历程，明确记录的长期目标与工具。</p>
<h1>印象笔记</h1>
<h1>OneNote</h1>
<h1>博客</h1>
<h1>语雀</h1>
<h1>flomo + 博客</h1>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/6" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="总结"/><published>2023-06-25T15:16:59+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/5</id><title>记录我的冥想</title><updated>2023-07-02T13:54:45.581830+00:00</updated><content type="html"><![CDATA[<h1>目标</h1>
<p>自动记录冥想，开始时间、结束时间、此刻的想法，看见自己的成长。</p>
<h1>任务</h1>
<ul>
<li><input disabled="" type="checkbox"> 完成一个自动记录冥想时间、冥想想法的工具🛠️</li>
</ul>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/5" rel="alternate"/><category term="WIP"/><category term="2023"/><category term="冥想"/><category term="TODO"/><published>2023-06-25T15:14:13+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/4</id><title>权限模型介绍</title><updated>2023-07-02T13:54:45.704645+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<h1>目标</h1>
<h1>权限模型</h1>
<h2>ACL</h2>
<h2>MAC</h2>
<h2>DAC</h2>
<h2>RBAC</h2>
<h2>ABAC</h2>
<h2>NGAC</h2>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/4" rel="alternate"/><category term="技术"/><category term="WIP"/><category term="2023"/><category term="权限"/><published>2023-06-25T14:18:54+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/3</id><title>利用 Github Issues 写博客</title><updated>2023-07-02T13:54:45.813117+00:00</updated><content type="html"><![CDATA[<h1>1 背景</h1>
<p>之前使用 Hexo 搭建过自己的博客 <a href="https://zzy131250.github.io">zzy131250</a>，用的是 Github Pages，主要目标是通过写作积累输出。
在工作后，写作比较少，加之更换电脑，原来本地的博客源码都没了。最近心血来潮，打算重新开始写作，但又懒得再去折腾 Hexo 博客，所以尝试使用 Github Issues 来写博客。
Github Issues 写博客配置简单，非常友好，这里记录下配置过程。</p>
<h2>1.1 优势</h2>
<ol>
<li>免费，不需要服务器或域名</li>
<li>自带评论功能</li>
<li>可以通过手机编辑和发布博客</li>
<li>可以通过 Actions 自动化</li>
</ol>
<h2>1.2 劣势</h2>
<ol>
<li>Github 访问不稳定，有时候需要科学上网</li>
</ol>
<h1>2 目标</h1>
<ol>
<li>使用 Github Issues 写博客，支持添加标签</li>
<li>通过 Github Actions 自动生成 README 和 RSS 订阅</li>
</ol>
<h1>3 流程</h1>
<h2>3.1 新建项目</h2>
<h2>3.2 编辑并上传文件</h2>
<h3>3.2.1 问题：本地 Push 代码到 Github 提示无法使用密码</h3>
<h2>3.3 配置 Github Actions</h2>
<h3>3.3.1 问题：Actions 运行报错，Push 代码报 403</h3>
<h1>4 效果</h1>
<h2>4.1 Issues</h2>
<img width="1245" alt="image" src="https://github.com/zzy131250/gitblog/assets/7437470/b8a3750a-2d5b-4d1c-942f-931c12b3de01">
<h2>4.2 Actions</h2>
<img width="1433" alt="image" src="https://github.com/zzy131250/gitblog/assets/7437470/d895db8d-1875-42a6-adae-cc9c32053e2b">
<h2>4.3 README</h2>
<img width="924" alt="image" src="https://github.com/zzy131250/gitblog/assets/7437470/d03aae65-b15f-4048-8135-b82bdc8d369f">
<h1>5 参考</h1>
<ol>
<li><a href="https://github.com/yihong0618/gitblog">gitblog</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1708679340950201611&amp;wfr=spider&amp;for=pc">使用 GitHub Issues 来写博客，真香</a></li>
</ol>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/3" rel="alternate"/><category term="技术"/><category term="WIP"/><category term="2023"/><published>2023-06-25T08:51:45+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/2</id><title>谈谈蓝牙4.0（BLE）模块与安卓的数据交互</title><updated>2023-07-02T13:54:45.937977+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>迁移自老博客，发表时间：2017-04-17</p>
</blockquote>
<p>开发蓝牙4.0也快两个月了，给我的感受还是颇多的。</p>
<p>我开发的是与TI的蓝牙模块CC2540交互的安卓端蓝牙软件，对于安卓都不是很熟悉的我，是一个不小的挑战。</p>
<p>我用的是google官方的源码，它本身把很多基本框架都搭好了。直接就能运行，当然前提是在Android Studio上，如果是Eclipse上还需要稍作改动。</p>
<p>我们先来看下代码。它主要有两个Avtivity和一个Service组成，顾名思义，两个Activity的用途分别为设备扫描与设备管理。</p>
<p>这里我不准备介绍基本的BLE知识（自行百度即可），我只是说一下一些需要注意的地方，特别是我百度不到的好多东西，希望跟大家分享一下。</p>
<p>一开始的软件已经可以查看Service和Characteristic的UUID，不过只能接收消息，原因大概是这个Sample当初设计的时候就只负责接收。当然要发送也简单，只要在BluetoothLeService中加writeCharacteristic方法。</p>
<pre><code class="language-Java">public boolean writeCharacteristic(BluetoothGattCharacteristic charac，String message){
    // check if mBluetoothGatt is available
    if (mBluetoothGatt == null) {
        Log.e(TAG, &quot;lost connection&quot;);
        return false;
    }
    charac.setValue(message.getBytes());
    boolean status = mBluetoothGatt.writeCharacteristic(charac);
    return status;
}
</code></pre>
<p>写数据比较简单，直接调用这个方法即可。当然，这里也有个陷阱，我们发现，如果你在CC2540中定义了Byte字节的长度，那么在charac.setValue()中的数组长度要跟其相同，不然模块是收不到的。</p>
<p>我们发现在很多地方都用到了BluetoothGattCharacteristic这个类，即特性，BLE就是靠改变特性值来传递数据的，那么，这些BluetoothGattCharacteristic是从哪里得到的呢？我们知道，BluetoothGattCharacteristic是BluetoothGattService中的属性，我们要得到BluetoothGattCharacteristic，就要先得到BluetoothGattService。那要怎么样得到BluetoothGattService呢？</p>
<pre><code class="language-Java">public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
    String intentAction;
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        intentAction = ACTION_GATT_CONNECTED;
        mConnectionState = STATE_CONNECTED;
        broadcastUpdate(intentAction);
        Log.i(TAG, &quot;Connected to GATT server.&quot;);
        // Attempts to discover services after successful connection.
        Log.i(TAG, &quot;Attempting to start service discovery:&quot; + mBluetoothGatt.discoverServices());
    } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
        intentAction = ACTION_GATT_DISCONNECTED;
        mConnectionState = STATE_DISCONNECTED;
        Log.i(TAG, &quot;Disconnected from GATT server.&quot;);
        broadcastUpdate(intentAction);
    }
}
</code></pre>
<p>这里先简单见一下回调，开发过安卓的朋友们应该了解，在安卓开发中，某个动作可能会出发后续的动作，这个被触发的动作就是回调。这里onConnectionStateChange函数就是在连接状态改变后会触发的回调，我们看到mBluetoothGatt.discoverServices()这里执行了发现服务的方法，那么在发现完服务呢？没错，它同样触发回调。</p>
<pre><code class="language-Java">public void onServicesDiscovered(BluetoothGatt gatt, int status) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
        broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);
    } else { 
        Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status);
    }
}
</code></pre>
<p>它会调用onServicesDiscovered(BluetoothGatt gatt, int status)方法，在这里它会发出一个广播broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED)。值得注意的是，在这里，BluetoothLeService与DeviceControlActivity交互的方式是广播。我们看到broadcastUpdate方法，在BluetoothLeService中。</p>
<pre><code class="language-Java">private void broadcastUpdate(final String action) {
    final Intent intent = new Intent(action);
    sendBroadcast(intent);
}
private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) {
    final Intent intent = new Intent(action);
    final byte[] data = characteristic.getValue();
    if (data != null &amp;&amp; data.length &gt; 0) {
        final StringBuilder stringBuilder = new StringBuilder(data.length);
        for(byte byteChar : data) {
            stringBuilder.append(String.format(&quot;%02X &quot;, byteChar));
        }
        intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString());
    }
    sendBroadcast(intent);
}
</code></pre>
<p>这里有两个broadcastUpdate，但效果是相似的，他们都调用sendBroadcast(intent)，至于sendBroadcast方法，就是底层的一些实现了，这里不用管他。我们知道了，在发现了服务之后，BluetoothLeService就sendBroadcast。那么，这个Broadcast传到哪里呢？答案是这里。</p>
<pre><code class="language-Java">private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        if (BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
            mBluetoothLeService.getSupportedGattServices()；
        }
    }
}
</code></pre>
<p>在DeviceControlActivity中有个onReceive方法，就是接受广播的地方。他通过参数intent的值判断广播的内容。ACTION_GATT_SERVICES_DISCOVERED这个参数表示发现服务。这里再调用getSupportedGattServices就可以获得服务啦。然后特性什么的就都知道了。</p>
<p>目前为止我们解决了往特性里写值的问题，那么，如何读取模块发来的消息呢？我们来说说具体的接收流程。</p>
<p>我们首先要明确的是，安卓端接收消息的被动的，它只能被动地告知要接收消息，而告诉他的人就是模块。这里我们说一下特性，特性有自身的一些属性，其实一个服务的每个特性都有自己独立的作用，这个可以自己定义，主要有可写，可读，还有专门用来通知的，即Notification，在模块改变了特性值，他得让手机知道，那么他就通过有Notification功能的特性发出通知。那么，如果模块的Service有好多特性，他怎么知道往哪个特性中发通知呢？所以，我们必须先告知模块我们通过哪个特性接收通知，代码如下。</p>
<pre><code class="language-Java">public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {
    if (mBluetoothAdapter == null || mBluetoothGatt == null) {
        Log.w(TAG, &quot;BluetoothAdapter not initialized&quot;);
        return;
    }
    BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(DeviceControlActivity.NotificationCharacDescripter));
    descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
    mBluetoothGatt.writeDescriptor(descriptor);  
    mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);
}
</code></pre>
<p>这里设置了BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE，相当于告知模块，我们从这个特性接受通知。然后，如果模块改变了其他特性值，他就会通过这个特性通知我们去读取。</p>
<p>在我们接收到通知后，安卓触发回调onCharacteristicChanged，并广播通知DeviceControlActivity去接收消息。</p>
<p>这里我们再看一下broadcastUpdate函数，这里调用的是private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic)。</p>
<pre><code class="language-Java">private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) {
    final Intent intent = new Intent(action);
    final byte[] data = characteristic.getValue();
    if (data != null &amp;&amp; data.length &gt; 0) {
        final StringBuilder stringBuilder = new StringBuilder(data.length);
        for(byte byteChar : data) {
            stringBuilder.append(String.format(&quot;%02X &quot;, byteChar));
        }
        intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString());
    }
    sendBroadcast(intent);
}
</code></pre>
<p>上面的代码中BluetoothLeService把接收的数据保存到了EXTRA_DATA里面。</p>
<pre><code class="language-Java">if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) {
    intent.getStringExtra(BluetoothLeService.EXTRA_DATA);
}
</code></pre>
<p>DeviceControlActivity再通过这里接收广播并取出数据，完成数据接收。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/2" rel="alternate"/><category term="技术"/><category term="Android"/><category term="BLE"/><category term="2017"/><published>2023-06-25T08:30:50+00:00</published></entry><entry><id>https://github.com/zzy131250/gitblog/issues/1</id><title>Github Issues 第一篇博客</title><updated>2023-07-02T13:54:46.052834+00:00</updated><content type="html"><![CDATA[<p>准备开始尝试使用 Github Issue 写博客，会慢慢把 ziazhou.com 上的博客迁移过来。</p>
]]></content><link href="https://github.com/zzy131250/gitblog/issues/1" rel="alternate"/><category term="2023"/><published>2023-06-25T03:52:09+00:00</published></entry></feed>